from itertools import count
from codecs import lookup
import mimetypes
import sys
import uu
import email
from email.header import decode_header
from email.parser import HeaderParser
from email.feedparser import NLCRE
from email.errors import MessageDefect
from io import BytesIO
from aes.core.sentry import sentry_client


custom_encodings_aliases = {
    'cp-850': 'cp850',
    'binary': 'latin_1',
    'unknown-8bit': 'latin_1',
    'iso-10646': 'utf_8',
    'iso-8859': 'latin_1',
    'ansi_x3.110-1983': 'iso8859_1',
    'we8iso8859p1': 'iso8859_1',
    'iso-8859-8-i': 'iso8859_8',
    'ms874': 'iso8859_11',
    'windows-874': 'iso8859_11',
    'utf8_spanish_ci': 'utf_8',
    '_iso-2022-jp$esc': 'iso2022_jp',
    'ibm904': 'latin_1',  # no better
    'jis_c6220-1969-jp': 'utf_8', # no better
    'charset=us-ascii': 'us_ascii',
    'charset="utf-8"': 'utf_8',
    'us-asci': 'us_ascii',
    'iso: western': 'iso8859_1',
    'x-ia5-german': 'cp1252'
}


class ReceivedHeaderDefect(MessageDefect):
    """Multiline Received header had no start identifiers in lines."""


def _compose_part_filename(msg_part, counter):
    filename = get_filename(msg_part)
    if not filename:
        ext = mimetypes.guess_extension(msg_part.get_content_type())
        if not ext:
            ext = '.bin'
        filename = 'part-{:03}{}'.format(next(counter), ext)
    return filename


def get_header(header):
    if not header:
        return ''
    try:
        tmp = ''
        for data, enc in decode_header(header):
            if isinstance(data, str):
                tmp += data
            else:
                enc = encoding_aliases(enc, failobj='raw-unicode-escape')
                tmp += data.decode(enc)
        header = tmp or header
    except BaseException:
        sentry_client.captureException()
    return header


def get_filename(msg_part):
    filename = msg_part.get_filename()
    if not filename:
        return ''
    return get_header(filename)


def mime_contents(msg):
    file_part_mapping = {}
    counter = count(1)
    for part in msg.walk():
        if part.get_content_maintype() == 'multipart':
            continue
        filename = _compose_part_filename(part, counter)
        file_part_mapping[filename] = part
    return file_part_mapping


def decode_mail_header(value, default_charset='us-ascii'):
    """
    Decode a header value into a unicode string.
    Works like a more smarter python
    C{u"".join(email.header.decode_header()} function

    @type value: str
    @param value: the value of the header.
    @type default_charset: str
    @keyword default_charset: if one charset used in the header (multiple
    charset can be mixed) is unknown, then use this charset instead.

    >>> decode_mail_header('=?iso-8859-1?q?Courrier_=E8l' +\
    'ectronique_en_Fran=E7ais?=')
    u'Courrier \\xe8lectronique en Fran\\xe7ais'
    """

    #    value=_friendly_header(value)
    try:
        headers = email.header.decode_header(value)
    except email.errors.HeaderParseError:
        # this can append in email.base64mime.decode(), for example
        # for this value:
        # '=?UTF-8?B?15HXmdeh15jXqNeVINeY15DXpteUINeTJ9eV16jXlSDXkdeg15XXl
        # deUINem15PXpywg15TXptei16bXldei15nXnSDXqdecINek15zXmdeZ?==?UTF-8?B
        # ?157XldeR15nXnCwg157Xldek16Ig157Xl9eV15wg15HXodeV15bXnyDXk9ec15DXnCD
        # Xldeh15gg157Xl9eR16rXldeqINep15wg15HXmdeQ?==?UTF-8?B?15zXmNeZ?='
        # then return a sanitized ascii string
        # Some improvements are possible here, but a failure
        # here is unlikely
        return value.encode('us-ascii', 'replace').decode('us-ascii')
    else:
        for i, (text, charset) in enumerate(headers):
            # python 3.x
            # email.header.decode_header('a') -> [('a', None)]
            # email.header.decode_header('a =?ISO-8859-1?Q?foo?= b')
            # --> [(b'a', None), (b'foo', 'iso-8859-1'), (b'b', None)]
            # in Py3 text is sometime str and sometime byte :-(
            # python 2.x
            # email.header.decode_header('a') -> [('a', None)]
            # email.header.decode_header('a =?ISO-8859-1?Q?foo?= b')
            # --> [('a', None), ('foo', 'iso-8859-1'), ('b', None)]
            if charset is None and sys.version_info >= (3, 0):
                # Py3
                if isinstance(text, str):
                    # convert Py3 string into bytes string to be sure
                    # their is no
                    # non us-ascii chars and because next line expect byte
                    # string
                    text = text.encode('us-ascii', 'replace')
            try:
                headers[i] = text.decode(charset or 'us-ascii', 'replace')
            except LookupError:
                # if the charset is unknown, force default
                headers[i] = text.decode(default_charset, 'replace')

        return "".join(headers)


def fix_missed_headers_after_received(raw_msg: str):
    """
    If after 'Received' header find line without tab or whitespace at
    begin, add this symbols and return fixed raw string.
    """

    msg_lines = raw_msg.splitlines(keepends=True)
    parser = HeaderParser()
    headers = []
    broken_lines = []
    for line_no, line in enumerate(msg_lines):
        if NLCRE.match(line):
            break
        if line.startswith(('\t', ' ')):
            continue
        res = parser.parsestr(line, headersonly=True)
        if res._headers:
            headers.append((res._headers[0][0], line_no))
            continue
        if headers and headers[-1][0] == 'Received':
            broken_lines.append(line_no)
    if broken_lines:
        for line_no in broken_lines:
            msg_lines[line_no] = '\t' + msg_lines[line_no]
        return ''.join(msg_lines), True
    return raw_msg, False


def encoding_aliases(enc, failobj=None):
    if enc is None:
        return failobj
    enc = enc.lower()
    try:
        codec_info = lookup(enc)
        if codec_info._is_text_encoding:
            return enc
        raise LookupError
    except LookupError:
        if enc in custom_encodings_aliases:
            return custom_encodings_aliases[enc]
        sentry_client.captureException()
        return failobj


def encode_uu(data):
    in_file = BytesIO(data)
    out_file = BytesIO()
    uu.encode(in_file, out_file)
    return out_file.getvalue()


def decode_uu(data):
    in_file = BytesIO(data)
    out_file = BytesIO()
    try:
        uu.decode(in_file, out_file, quiet=True)
        return out_file.getvalue()
    except uu.Error:
        return data
