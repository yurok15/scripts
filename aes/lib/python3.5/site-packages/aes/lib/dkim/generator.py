from email.generator import BytesGenerator

from aes.lib.dkim.dkim import DKIMSign


class DKIMGenerator(BytesGenerator):
    _NL = None
    _encoded_NL = None
    _EMPTY = None
    _encoded_EMTPY = None

    def __init__(self, outfp, dkim_settings,
                 mangle_from_=None, maxheaderlen=None, *, policy=None):
        self.dkim = DKIMSign(**dkim_settings)
        super(DKIMGenerator, self).__init__(outfp, mangle_from_=mangle_from_,
                                            maxheaderlen=maxheaderlen,
                                            policy=policy)

    def generate(self, msg):
        self._NL = msg.policy.linesep
        self._encoded_NL = self._encode(self._NL)
        self._EMPTY = ''
        self._encoded_EMTPY = self._encode('')
        self.policy = msg.policy
        self._write_with_sign(msg)

    def _write_headers_with_sign(self, msg):
        headers = []
        for h, v in msg.raw_items():
            folded = self.policy.fold(h, v)
            headers.append(folded)
            if h.lower() in self.dkim.req_headers:
                self.dkim.add_header(h, folded)
        header = self.dkim.create_header(linesep=self._encoded_NL,
                                         linelen=self.maxheaderlen)
        self._fp.write(header)
        for header in headers:
            self.write(header)
        self.write(self._NL)

    def _write_with_sign(self, msg):
        oldfp = self._fp
        self._fp = sfp = self._new_buffer()
        self._dispatch(msg)
        self._fp = oldfp
        body = sfp.getvalue()
        self.dkim.add_body(body)
        self._write_headers_with_sign(msg)
        self._fp.write(body)

    def clone(self, fp):
        return BytesGenerator(fp,
                              self._mangle_from_,
                              None,
                              policy=self.policy)
