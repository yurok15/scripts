import re
from time import time
from base64 import b64encode
from Crypto.Hash import SHA, SHA256
from Crypto.PublicKey import RSA
from Crypto.Signature import PKCS1_v1_5


CRLF = re.compile(b'(\r?\n)')
CRLF_ENDINGS = re.compile(b'(\r?\n)*$')
SP_AT_ENDINGS = re.compile(b'([\t ]+)?(\r?\n)')
WSP_SEQ = re.compile(b'[\t ]+')
WSP_AROUND_SEMICOLON = re.compile(b'[\t ]?:[\t ]?')


class DKIMError(Exception):
    pass


class InvalidRSAKey(DKIMError):
    pass


class SimpleCanonicalization:
    name = 'simple'

    @staticmethod
    def canon_header(header):
        return CRLF.sub(b'\r\n', header)

    @staticmethod
    def canon_body(body):
        """
        Converts "*CRLF" at the end of the body to a single "CRLF".
        """

        i = 0
        lines = body.splitlines()
        for i, line in enumerate(reversed(lines)):
            if line:
                break
        if i:
            lines = lines[:-i]
        if not lines:
            lines.append(b'')
        lines.append(b'')
        return b'\r\n'.join(lines)


class RelaxedCanonicalization(SimpleCanonicalization):
    name = 'relaxed'

    @staticmethod
    def canon_header(header):
        """
        1. Convert all header field names to lowercase.
        2. Unfold all header field continuation lines.
        3. Convert all WSP sequences to a single SP character.
        4. Delete all WSP characters at the end of each unfolded header field
           value.
        5. Delete any WSP characters remaining before and after the colon
           separating the header field name from the header field value.
        """
        h, v = header.split(b':', 1)
        data = h.lower() + b':' + v
        data = CRLF.sub(b'', data)
        data = WSP_SEQ.sub(b' ', data)
        data = data.rstrip() + b'\r\n'
        data = WSP_AROUND_SEMICOLON.sub(b':', data)
        return data

    @staticmethod
    def canon_body(body):
        """
        1. Ignore all whitespace at the end of lines.
        2. Reduce all sequences of WSP within a line to a single SP character.
        3. Ignore all empty lines at the end of the message body. If the body
           is non-empty but does not end with a CRLF, a CRLF is added.
        """

        lines = [WSP_SEQ.sub(b' ', line.rstrip()) for line in body.splitlines()]
        i = 0
        for line in reversed(lines):
            if line:
                break
            i += 1
        if i:
            lines = lines[:-i]
        if lines:
            lines.append(b'')
        return b'\r\n'.join(lines)


class DKIMSign:
    """
    RFC 6376 DomainKeys Identified Mail (DKIM) Signatures

    v=  Version
    a=  The algorithm used to generate the signature (rsa-sha1" or "rsa-sha256")
    b=  The signature data (base64; REQUIRED)
    bh= The hash of the canonicalized body part of the message as
        limited by the "l=" tag (base64; REQUIRED)
    c=  Message canonicalization
    d=  The SDID claiming responsibility for an introduction of a message
        into the mail stream (plain-text; REQUIRED). The SDID MUST
        correspond to a valid DNS name under which the DKIM key record is
        published
    h=  Signed header fields
    i=  The Agent or User Identifier (AUID) on behalf of which the SDID is
        taking responsibility
    l=  Body length count
    q=  A colon-separated list of query methods used to retrieve the
        public key (plain-text; OPTIONAL, default is "dns/txt")
    s=  The selector subdividing the namespace for the "d=" (domain) tag
    t=  Signature Timestamp
    x=  Signature Expiration
    z=  Copied header fields
    """

    defaults = {
        'hash_alg': 'rsa-sha256',
        'h_canon': 'relaxed',
        'b_canon': 'simple',
        'headers': {'from', 'to', 'subject', 'date', 'message-id'}
    }

    def __init__(self,
                 private_key,
                 selector,
                 domain,
                 user,
                 hash_alg=None,
                 h_canon=None,
                 b_canon=None,
                 headers=None):
        try:
            self.key = RSA.importKey(
                b'-----BEGIN RSA PRIVATE KEY-----\n' +
                private_key +
                b'\n-----END RSA PRIVATE KEY-----')
        except (ValueError) as e:
            raise InvalidRSAKey from e
        self.selector = selector
        self.domain = domain
        self.user = user
        self.hash_alg = hash_alg or self.defaults['hash_alg']
        self.hash_class = SHA256 \
            if self.hash_alg == 'rsa-sha256' else SHA
        self.req_headers = self.defaults['headers'].copy()
        if headers:
            self.req_headers.update(set(headers))
        self.sign_headers = []
        self.sign_headers_values = []

        h_canon = h_canon or self.defaults['h_canon']
        h_canon_cls = SimpleCanonicalization() \
            if h_canon == 'simple' else RelaxedCanonicalization()
        b_canon = b_canon or self.defaults['b_canon']
        b_canon_cls = SimpleCanonicalization() \
            if b_canon == 'simple' else RelaxedCanonicalization()
        self.h_canon = h_canon_cls.canon_header
        self.b_canon = b_canon_cls.canon_body
        self.canonicalization = '%s/%s' % (h_canon_cls.name, b_canon_cls.name)
        self.bodyhash = None

    def add_body(self, body):
        hash_func = self.hash_class.new()
        hash_func.update(self.b_canon(body))
        bodyhash = hash_func.digest()
        self.bodyhash = b64encode(bodyhash)

    def add_header(self, header_name, raw_header):
        if hasattr(raw_header, 'encode'):
            raw_header = raw_header.encode('ascii')
        data = self.h_canon(raw_header)
        h_name = header_name.lower()
        if h_name in self.sign_headers:
            curr = data
            for i, h in enumerate(self.sign_headers):
                if h == h_name:
                    prev = self.sign_headers_values[i]
                    self.sign_headers_values[i] = curr
                    curr = prev
            data = curr
        self.sign_headers.append(h_name)
        self.sign_headers_values.append(data)

    def create_header(self, linesep=None, linelen=None):
        header = self.prepare_header(linesep, linelen)
        self.sign_headers_values.append(self.h_canon(header).rstrip())
        hash_func = self.hash_class.new()
        for h in self.sign_headers_values:
            hash_func.update(h)
        signer = PKCS1_v1_5.new(self.key)
        signature = signer.sign(hash_func)
        signature = b64encode(signature)
        return header + self.fold_signature(signature, linesep, linelen)

    def prepare_header(self, linesep=None, linelen=None):
        header = 'DKIM-Signature: ' + '; '.join(['%s=%s' % f for f in [
            ('v', '1'),
            ('a', self.hash_alg),
            ('c', self.canonicalization),
            ('d', self.domain),
            ('i', self.user),
            ('q', 'dns/txt'),
            ('s', self.selector),
            ('t', str(int(time()))),
            ('h', ':'.join(h for h in self.sign_headers)),
            ('bh', self.bodyhash.decode('ascii')),
            ('b', '')]])
        header = header.encode('ascii')
        return self.fold_header(header, linesep, linelen)

    @staticmethod
    def fold_header(header, linesep=None, linelen=None):
        linesep = linesep or b'\n'
        linelen = linelen or 80
        partlen = linelen - len(linesep)
        lines = []
        begin = end = 0
        for i, c in enumerate(header):
            if c == 59:
                end = i + 1
            if i - begin > partlen:
                lines.append(header[begin:end])
                begin = end
        if begin != end:
            lines.append(header[begin:end])
        lines.append(header[end:])
        header = (linesep + b'\t').join(lines)
        return header

    @staticmethod
    def fold_signature(signature, linesep=None, linelen=None):
        linesep = linesep or b'\n'
        linelen = linelen or 80
        partlen = linelen - 4 - len(linesep)
        lines = []
        lines.append(signature[:partlen])
        signature = signature[partlen:]
        while signature:
            lines.append(b'\t   ' + signature[:partlen])
            signature = signature[partlen:]
        return linesep.join(lines) + linesep
