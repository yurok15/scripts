import asyncio
from functools import wraps
import logging

import aiohttp

from aes.lib.connection_pool import BaseConnector


class BaseNetworkConnector(BaseConnector):
    protocol_cls = object
    retry_exceptions = (ConnectionResetError,)

    def __init__(self, loop, timeout=15, retry_attempts=3, **kwargs):
        super(BaseNetworkConnector, self).__init__(loop)
        self.transport = None
        self.protocol = None
        self.kwargs = kwargs
        self.timeout = timeout
        self.retry_attempts = retry_attempts
        self.cls = self.protocol_cls or self.__class__
        self.logger = logging.getLogger(self.cls.__name__ + '.connection_pool')

    def open_connection(self):
        raise NotImplementedError

    async def start(self):
        self.protocol = await asyncio.wait_for(
            self.open_connection(),
            timeout=self.timeout,
            loop=self.loop,
        )

    def protocol_factory(self):
        return self.cls(self.loop, timeout=self.timeout, **self.kwargs)

    async def reconnect(self):
        self.close()
        await self.start()

    def close(self):
        if self.protocol:
            self.protocol.close()
            self.protocol = None

    @property
    def disconnected(self):
        return (not self.protocol) or self.protocol.disconnected

    @classmethod
    def retry_connect(cls, f):
        @wraps(f)
        async def wrapped(connector: cls, *args, **kwargs):
            counter = connector.retry_attempts
            while counter > 0:
                try:
                    if connector.disconnected:
                        await connector.reconnect()
                    return await f(connector, *args, **kwargs)
                except Exception as e:
                    if any((isinstance(e, x) for x in
                            connector.retry_exceptions)):
                        counter -= 1
                        if counter > 0:
                            connector.logger.debug(
                                'Retry on exception "%s", try %s',
                                e,
                                counter
                            )
                        else:
                            connector.logger.warning('Retry limit exceeded')
                            raise
                    else:
                        raise
        return wrapped


class BaseTCPConnector(BaseNetworkConnector):
    default_host = '127.0.0.1'
    default_port = None

    def __init__(self, loop, host=None, port=None, **kwargs):
        super(BaseTCPConnector, self).__init__(loop, **kwargs)
        self.host = host or self.default_host
        assert self.host
        self.port = port or self.default_port
        assert self.port

    async def open_connection(self):
        _, protocol = await self.loop.create_connection(
            self.protocol_factory, self.host, self.port
        )
        await protocol.started
        return protocol


class BaseUnixConnector(BaseNetworkConnector):
    default_unix_path = None

    def __init__(self, loop, unix_path=None, **kwargs):
        super(BaseUnixConnector, self).__init__(loop, **kwargs)
        self.unix_path = unix_path or self.default_unix_path
        assert self.unix_path

    async def open_connection(self):
        _, protocol = await self.loop.create_unix_connection(
            self.protocol_factory, self.unix_path
        )
        await protocol.started
        return protocol


class BaseHTTPConnector(BaseNetworkConnector):
    protocol_cls = aiohttp.ClientSession

    async def open_connection(self):
        return self.protocol_cls(loop=self.loop)

    @property
    def disconnected(self):
        return (self.protocol is None) or self.protocol.closed
