import asyncio
import logging
from aes.core.sentry import sentry_client

logger = logging.getLogger(__name__)

DEFAULT_LIMIT = 2 ** 18


class ChatStreamReader(asyncio.StreamReader):
    def __init__(self, protocol, limit, timeout, loop):
        super(ChatStreamReader, self).__init__(limit=limit, loop=loop)
        self.protocol = protocol
        self._timeout = timeout

    async def read_line(self, separator=None, encoding=None, strip_sep=True):
        separator = separator or self.protocol.default_line_separator
        assert separator
        line = await asyncio.wait_for(
            self.readuntil(separator=separator),
            timeout=self._timeout,
            loop=self._loop,
        )
        if strip_sep:
            line = line.rstrip(separator)
        encoding = encoding or self.protocol.default_encoding
        if encoding:
            return str(line, encoding=encoding)
        return line


class ChatStreamWriter(asyncio.StreamWriter):
    async def write_line(self, data, separator=None, encoding=None,
                         add_sep=True):
        encoding = encoding or self._protocol.default_encoding
        if encoding and not isinstance(data, bytes):
            data = bytes(data, encoding=encoding)
        if add_sep:
            separator = separator or self._protocol.default_line_separator
            data += separator
        self.write(data)
        return await self.drain()


class BaseChatProtocol(asyncio.StreamReaderProtocol):
    default_encoding = None
    default_line_separator = b'\n'

    def __init__(self, loop, timeout=15, limit=DEFAULT_LIMIT):
        self._limit = limit
        self._timeout = timeout
        self.loop = loop
        self._reader = ChatStreamReader(
            self, self._limit, self._timeout, loop)
        asyncio.StreamReaderProtocol.__init__(
            self, self._reader, loop=loop)
        logger_name = self.__class__.__name__ + '.service_pool'
        self.logger = logging.getLogger(logger_name)
        self._handler_task = None
        self.started = loop.create_future()

    def connection_made(self, transport):
        self._connection_lost = False
        self.logger.debug('Connection established')
        super(BaseChatProtocol, self).connection_made(transport)
        self._stream_writer = ChatStreamWriter(
            transport, self, self._stream_reader, self._loop
        )
        self._handler_task = self._loop.create_task(
            self._handler(self._stream_reader, self._stream_writer)
        )

    async def _handler(self, reader, writer):
        try:
            await self.handle_client(reader, writer)
        except Exception as e:
            if not self.started.done():
                self.started.set_exception(e)
            sentry_client.captureException()
            logger.exception(str(e))

    async def handle_client(self, reader, writer):
        self.started.set_result(self)

    @property
    def disconnected(self):
        return (self._stream_reader is None) or self._stream_reader.at_eof()

    def connection_lost(self, exc):
        self.logger.debug('Connection lost')
        if not self.started.done():
            self.started.set_result(self)
        return super(BaseChatProtocol, self).connection_lost(exc)

    def close(self):
        if self._stream_writer:
            self._stream_writer.close()

    def _get_reader_buffer(self):
        data = self._reader._buffer.decode(
            self.default_encoding or 'utf-8').strip()
        return data
