import asyncio
import logging
import time

logger = logging.getLogger(__name__)


class ConnectorRecoverableException(Exception):
    pass


class BaseConnector:
    def __init__(self, loop):
        self.loop = loop

    async def start(self):
        pass

    def close(self):
        pass


class ConnectorManager:
    def __init__(self, service_pool, service, name):
        super(ConnectorManager, self).__init__()
        self._service_pool = service_pool
        self._service = service
        self.name = name
        self.failed = False
        self.created = time.time()
        self.updated = time.time()
        self.used_count = 0
        self.used_time = 0
        self.in_use = False

    @property
    def avg_used_time(self):
        return self.used_time / self.used_count if self.used_count else 0

    def __enter__(self):
        self.updated = time.time()
        self.in_use = True
        return self._service

    def __exit__(self, exc_type, *args):
        if exc_type and not isinstance(exc_type, ConnectorRecoverableException):
            self.failed = True
            self._service.close()
        self.in_use = False
        self.used_count += 1
        self.used_time += time.time() - self.updated
        self._service_pool.connector_stopped(self)


class ConnectionPool:
    def __init__(self, loop, connector_factory, limit=None, **kwargs):
        super(ConnectionPool, self).__init__()
        self.loop = loop
        self.connector_factory = connector_factory
        self.factory_kwargs = kwargs
        self.pool_limit = limit
        self.pool = []
        self.free_pool = []
        self.started = False
        self.queue = []
        self.name = connector_factory.__name__
        self._logger = logging.getLogger(self.name + '.service_pool')
        self.counter = 0

    def log(self, msg, *args, **kwargs):
        self._logger.debug(msg, *args, extra=kwargs)

    async def start(self, pool_size):
        self.log('Starting with size %s', pool_size)
        while len(self.pool) < pool_size:
            await self._create_connector()

    def connector_started(self, connector: ConnectorManager):
        self.log('Service started #%s', connector.name)
        if connector in self.free_pool:
            self.free_pool.remove(connector)

    def connector_stopped(self, connector: ConnectorManager):
        if self.queue:
            future = self.queue.pop(0)
            future.set_result(connector)
            self.log('Connector finished #%s, notify queue', connector.name)
        else:
            self.log('Connector finished #%s, now free', connector.name)
            if connector.failed:
                self.pool.remove(connector)
                if connector in self.free_pool:
                    self.free_pool.remove(connector)
            elif connector not in self.free_pool:
                self.free_pool.append(connector)

    async def _create_connector(self) -> ConnectorManager:
        conn = self.connector_factory(loop=self.loop, **self.factory_kwargs)
        self.counter += 1
        manager = ConnectorManager(self, conn, self.counter)
        await conn.start()
        self.pool.append(manager)
        self.free_pool.append(manager)
        self.log('Created service #%s', manager.name)
        return manager

    async def get(self):
        while self.free_pool:
            connector = self.free_pool[0]
            self.log('Return free connector #%s from pool', connector.name)
            self.connector_started(connector)
            return connector
        if (not self.pool_limit) or (len(self.pool) < self.pool_limit):
            connector = await self._create_connector()
            self.log('Return new connector #%s', connector.name)
            self.connector_started(connector)
            return connector
        self.log('Wait for connector to finish')
        f = asyncio.Future(loop=self.loop)
        self.queue.append(f)
        connector = await f
        if not connector.failed:
            self.log('Return awaited connector #%s', connector.name)
            self.connector_started(connector)
            return connector
        self.log('Awaited connector #%s failed, remove', connector.name)
        self.pool.remove(connector)
        if connector in self.free_pool:
            self.free_pool.remove(connector)
        connector = await self._create_connector()
        self.log('Awaited connector failed, return new one #%s', connector.name)
        self.connector_started(connector)
        return connector

    def close(self):
        while self.pool:
            manager = self.pool.pop()
            with manager as service:
                service.close()
        self.free_pool = []

    def report(self):
        return {
            'limit': self.pool_limit,
            'queue_length': len(self.queue),
            'pool_length': len(self.pool),
            'free_count': len(self.free_pool),
            'pool': [{
                'name': ctx.name,
                'in_use': ctx.in_use,
                'used_count': ctx.used_count,
                'used_time': ctx.used_time,
                'used_avg_time': ctx.avg_used_time,
                'created_ago': time.time() - ctx.created,
                'updated_ago': time.time() - ctx.updated,
            } for ctx in self.pool]
        }
