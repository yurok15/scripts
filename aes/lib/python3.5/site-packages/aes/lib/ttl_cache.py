import logging
import asyncio
import time
from collections import OrderedDict

logger = logging.getLogger(__name__)


class TTLCache:
    def __init__(self, loop, lru=100, ttl=60, target=None):
        super(TTLCache, self).__init__()
        self.lru = lru
        self.ttl = ttl
        self.loop = loop
        self._cache = OrderedDict()
        self._target = target
        self._hits = 0
        self._misses = 0
        self._expired = 0
        self._evicted = 0

    @property
    def hits(self):
        return self._hits

    @property
    def misses(self):
        return self._misses

    @property
    def expired(self):
        return self._expired

    @property
    def evicted(self):
        return self._evicted

    def _log(self, s, *args):
        logger.debug(self.__class__.__name__ + ': ' + s, *args)

    async def load_data(self, key):
        if self._target:
            return await self._target(key)
        raise NotImplementedError

    def _key_hit(self):
        self._hits += 1

    def _key_miss(self):
        self._misses += 1

    def _key_expire(self):
        self._expired += 1

    def _key_evicted(self):
        self._evicted += 1

    async def get(self, key):
        if key in self._cache:
            data = self._cache.get(key)
            if isinstance(data, asyncio.Future):
                self._log('Returning "%s" from future', key)
                self._key_hit()
                return await data
            if time.time() - data[0] >= self.ttl:
                self._key_expire()
                self._log('Deleting "%s" from cache by TTL', key)
                del self._cache[key]
            else:
                self._key_hit()
                self._log('Returning "%s" from cache', key)
                return data[1]
        self._key_miss()
        data = None
        f = asyncio.Future(loop=self.loop)
        self._cache[key] = f
        self._log('Lock cache key "%s"', key)
        t = time.time()
        try:
            data = await self.load_data(key)
        finally:
            if data is None:
                self._log('Unlock cache key "%s"', key)
                del self._cache[key]
            else:
                self._log('Set cache for "%s"', key)
                self._cache[key] = t, data
                if len(self._cache.keys()) > self.lru:
                    self._key_evicted()
                    self._cache.popitem(last=False)
            f.set_result(data)
        return data

    def __getitem__(self, item):
        return self.get(key=item)

    def clear(self):
        count = len(self._cache)
        self._cache.clear()
        return count
