from base64 import b64encode, b64decode
from Crypto.Cipher import AES

from aes.core.exceptions import ImproperlyConfigured


IV = b'\xd2\x82z\x83\x84r^=6g\xf5-.y\xf2\xff'


class AESEncoder:

    def __init__(self, key):
        key_length = len(key)
        if key_length not in [16, 24, 32]:
            raise ImproperlyConfigured('Wrong secret key length')
        self.key = key
        self.key_length = key_length

    def encode(self, data):
        crypter = AES.new(self.key, AES.MODE_CBC, IV)
        data = self._normalize(data)
        data = crypter.encrypt(data)
        data = b64encode(data, b'-_')
        data = data.replace(b'=', b'~').decode()
        return data

    def _normalize(self, data):
        data = data.encode()
        padding = (len(self.key) - (len(data) % len(self.key)))
        normalized = (data + b' ' * padding)
        return normalized.decode()

    def decode(self, data):
        crypter = AES.new(self.key, AES.MODE_CBC, IV)
        data = data.replace('~', '=')
        data = b64decode(data, b'-_')
        data = crypter.decrypt(data)
        data = data.decode()
        data = self._denormalize(data)
        return data

    def _encode_key(self, data):
        crypter = AES.new(self.key, AES.MODE_ECB)
        padding = (len(self.key) - (len(data) % len(self.key)))
        data = (data + b'\x00' * (padding - 1) + chr(padding).encode('ascii'))
        data = crypter.encrypt(data)
        data = b64encode(data)
        return data.decode('ascii')

    def _decode_key(self, data):
        crypter = AES.new(self.key, AES.MODE_ECB)
        data = b64decode(data)
        data = crypter.decrypt(data)
        padding = data[-1] if data[-1] < len(self.key) else 0
        data = data[:-padding] if padding else data
        return data

    @staticmethod
    def _denormalize(data):
        return data.rstrip(' ')
