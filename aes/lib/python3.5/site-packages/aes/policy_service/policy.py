import asyncio
from collections import OrderedDict

from aes.core.exceptions import InvalidRecipientPolicy
from aes.core.statistics import prometheus
from aes.lib.encoders import AESEncoder
from aes.lib.dkim.dkim import InvalidRSAKey
from .cache import PolicyCache, CachedPolicyPool, cache_names


DEFAULT_POLICY_SIZE_LIMIT = 1024 * 1024 * 3


class PolicyNotFoundError(Exception):
    pass


class UserPolicy:
    def __init__(self, policy_pool, user, policy_list):
        self.policy_pool = policy_pool  # type: MailFilteringPolicyPool
        self.user = user
        self.list = policy_list
        self.filtering = None
        self.applied_policies = []
        self._transport = {}
        self.policy_types = {p['policy_type']: p for p in self.list}
        self.tenant_id = None
        self.trusted_hosts = []
        self.domains = []

    async def load_filtering_policies(self, inbound: bool):
        filtering_prefix = 'inbound_' if inbound else 'outbound_'
        account_policy_type = 'tenant'
        group_type = filtering_prefix + 'filtering'
        personal_type = filtering_prefix + 'personal'
        filtering_types = OrderedDict([
            ('global', filtering_prefix + 'global'),
            ('account', account_policy_type),
            ('group', filtering_prefix + 'filtering'),
            ('personal', personal_type)
        ])

        self.filtering = OrderedDict()
        personal_enabled = True
        for cache_name, policy_type in filtering_types.items():
            cache = self.policy_pool.caches[policy_type]
            info = self.policy_types.get(policy_type) or {}
            policy_id = info.get('policy_id')
            if policy_id:
                if (not personal_enabled and
                        policy_type == personal_type):
                    continue
                # Add versions support
                policy = await cache[policy_id]
                if policy is not None:
                    if policy_type == account_policy_type:
                        personal_enabled = policy.get('user_quarantine_enabled')
                        self.trusted_hosts = policy.get('trusted_servers') or []
                    if policy_type == group_type:
                        self.tenant_id = info.get('tenant_id')
                    self.filtering[cache_name] = policy
                    self.applied_policies.append(info)
        if 'group' not in self.filtering:
            raise InvalidRecipientPolicy('No user group policy')

    async def _get_transport_policy(self, policy_type):
        if policy_type not in self.policy_types:
            return
        info = self.policy_types.get(policy_type) or {}
        cache = self.policy_pool.transport_caches[policy_type]
        policy_id = info.get('policy_id')
        if policy_id:
            # Add versions support
            policy = await cache[policy_id]
            if policy is not None:
                self.applied_policies.append(info)
                return policy

    async def transport(self, inbound):
        name = 'inbound_transport' if inbound else 'outbound_transport'
        if name in self._transport:
            return self._transport[name]
        policy = await self._get_transport_policy(name)
        if not policy or 'next_hop' not in policy:
            raise InvalidRecipientPolicy('No user %s policy' % name)
        next_hop = policy['next_hop']
        if next_hop.startswith('smtp:'):
            next_hop = next_hop[5:]
        if ':' in next_hop:
            host, port = next_hop.split(':')
            policy = host, int(port)
        else:
            policy = next_hop, 25
        self._transport[name] = policy
        return policy

    async def load_domains(self):
        cache = self.policy_pool.caches['domains']
        domains = await cache[self.tenant_id]
        if not domains:
            raise InvalidRecipientPolicy('No tenant domains', self.tenant_id)
        for domain_rec in domains:
            domain = domain_rec.get('domain_name', '').lower()
            if domain and domain not in self.domains:
                self.domains.append(domain)

    def get_dkim_settings(self, domain):
        for p_type in self.filtering:
            dkim_policy = self.filtering[p_type].get('dkim') or {}
            domains = dkim_policy.get('domains') or []
            for conf in domains:
                if conf.get('name', '') == domain and conf.get('enabled'):
                    try:
                        priv_key = self.policy_pool.key_encoder._decode_key(
                            conf.get('private_key'))
                    # I have no idea why it is not covered sometimes.
                    # There is a test that guarantees that it is called.
                    # Looks like it is a bug in coverage or pytest.
                    except BaseException as e:  # pragma: no cover
                        raise InvalidRSAKey from e
                    return {
                        'private_key': priv_key,
                        'selector': conf.get('selector'),
                        'domain': domain,
                        'user': self.user
                    }


class MailFilteringPolicyPool(CachedPolicyPool):
    not_found_error = PolicyNotFoundError

    def __init__(self, loop, config):
        super(MailFilteringPolicyPool, self).__init__(
            config['url'],
            loop,
            limit=config.get('pool_limit'),
            content_length_limit=config.get('content_limit',
                                            DEFAULT_POLICY_SIZE_LIMIT),
            chunk_size=config.get('chunk_size', None)
        )
        lru_count = config['lru']
        ttl_count = config['ttl']
        self.key_encoder = AESEncoder(config.get('secret_key', None))

        self.caches = {}
        for name in cache_names:
            kwargs = dict(lru=lru_count)
            if name == 'list':
                kwargs['ttl'] = ttl_count
                kwargs['target'] = self._get_policies_list
            elif name == 'domains':
                kwargs['ttl'] = ttl_count
                kwargs['target'] = self._get_tenant_domains
            else:
                kwargs['target'] = self._get_policy
                # Remove ttl here when versions will be ready
                kwargs['ttl'] = ttl_count
            self.caches[name] = PolicyCache(name, loop, **kwargs)
        self.timeout = config.get('timeout')
        self.transport_caches = {
            'inbound_transport': self.caches['inbound_transport'],
            'outbound_transport': self.caches['outbound_transport'],
        }

    async def _get_policy(self, policy_id):
        url = self.get_url(
            '/policies/{policy_id}/settings',
            policy_id=policy_id
        )
        return await asyncio.wait_for(
            self.json(url),
            timeout=self.timeout,
            loop=self.loop,
        )

    async def _get_policies_list(self, key):
        url = self.get_url(
            '/recipients/{emailAddress}/policies',
            emailAddress=key,
        )
        return await asyncio.wait_for(
            self.json(url),
            timeout=self.timeout,
            loop=self.loop,
        )

    async def _get_tenant_domains(self, tenant_id):
        url = self.get_url(
            '/tenants/{tenant_id}/domains',
            tenant_id=tenant_id
        )
        return await asyncio.wait_for(
            self.json(url),
            timeout=self.timeout,
            loop=self.loop,
        )

    @prometheus('get_full_policy')
    async def get_full_policy(self, user, inbound: bool):
        policy_list = await self.caches['list'][user]
        if not policy_list:
            raise InvalidRecipientPolicy('Unknown email address')
        policy = UserPolicy(self, user, policy_list)
        await policy.load_filtering_policies(inbound)
        await policy.load_domains()
        return policy
