import re
import copy
import logging

from aes.message import MessageInfo, Category, SkipFlags
from aes.filters.base import BaseFilter
from aes.filters.base_actions import (
    AdminQuarantineDelivery,
    CopyToQuarantine,
    DenyDelivery,
    PassAction,
)
from aes.core.exceptions import InvalidRecipientPolicy
from aes.core.sentry import sentry_client
from aes.lib.mime import get_header, encoding_aliases
from .searcher import search

logger = logging.getLogger(__name__)


class CopyToAdminQuarantine(CopyToQuarantine):
    def apply(self, message, smtp_endpoint=None, quarantine_type=None,
              reason=None, **kwargs):
        super(CopyToAdminQuarantine, self).apply(
            message, smtp_endpoint=smtp_endpoint,
            quarantine_type='AdminQuarantine', reason=reason, **kwargs)


class ContentActions:
    reasons = None
    bypass = None
    quarantine = None
    deny = None


class ContentFilter(BaseFilter):
    allow_multiple_policy = True

    actions = {
        'bypass': PassAction(),
        'quarantine': AdminQuarantineDelivery('content', Category.CONTENT),
        'admin_quarantine': AdminQuarantineDelivery(
            'content', Category.CONTENT),
        'deny_delivery': DenyDelivery('content', Category.CONTENT),
        'send_and_quarantine': CopyToAdminQuarantine(
            'content', Category.CONTENT)
    }
    skip_flag = SkipFlags.CONTENT

    default_headers = [
        'From', 'To', 'Subject', 'Reply-To', 'Content-Disposition']

    def __init__(self, name, controller, config, loop):
        super(ContentFilter, self).__init__(name, controller, config, loop)
        self.headers = config.get('headers') or self.default_headers

    def _match(self, message: MessageInfo, rules) -> list:
        matched_rules = []
        body_attachs = []
        matched_rules += self.check_headers(message.email, rules)
        if message.email.is_multipart():
            for part in message.attachments:
                matched_rules += self.check_headers(part.attach, rules)
                if part.is_body:
                    body_attachs.append(part.attach)
        elif len(message.attachments) == 0:
            body_attachs.append(message.email)

        for attach in body_attachs:
            enc = encoding_aliases(
                attach.get_content_charset(), failobj='utf-8')
            payload = attach.get_payload(decode=True)
            try:
                data = payload.decode(encoding=enc)
            except UnicodeDecodeError:
                data = payload.decode(
                    encoding='latin1', errors='surrogateescape')
            result = search(rules, data)
            if result:
                matched_rules += result
        return matched_rules

    @staticmethod
    def _collapse_rules(message: MessageInfo, matched_rules):
        applied = []
        reasons = []
        result = ContentActions()
        for rule in matched_rules:
            if rule in applied:
                continue
            applied.append(rule)
            if 'display_name' in rule and rule['display_name'] is not None:
                reasons.append(rule['display_name'])
            actions = rule.get('actions') or []
            for action in actions:
                name = action.get('name', '')
                if name == 'bypass':
                    result.bypass = action
                elif name == 'quarantine':
                    result.quarantine = action
                elif name == 'deny_delivery':
                    result.deny = action
                elif name == 'send_silent_copy':
                    recipients = action.get('recipients')
                    if recipients and not message.silent_copy:
                        message.silent_copy = [{
                            'recipients': recipients,
                            'rule': rule.get('display_name'),
                        }]
                elif action is not None:
                    sentry_client.captureMessage(
                        'Undefined action ' + str(action))
        result.reasons = ', '.join(reasons)
        return result

    async def process(self, message: MessageInfo, content=None):
        rules = self._parse_rules(content)
        if not rules:
            return
        matched_rules = self._match(message, rules)
        result = self._collapse_rules(message, matched_rules)

        result_action = result.bypass or {'name': 'bypass'}
        if result.quarantine:
            if result.bypass:
                result.quarantine = result.quarantine.copy()
                result.quarantine.update(name='send_and_quarantine')
            result_action = result.quarantine
        elif result.deny and not result.bypass:
            result_action = result.deny

        log_msg = None
        if result.reasons:
            log_msg = 'match: ' + result.reasons
            logger.info(log_msg)

        self.apply_action(message, **result_action,
                          reason=log_msg[:160] if log_msg else 'content')
        return log_msg

    def check_headers(self, mime_obj, rules):
        matched_rules = []
        for header_name in self.headers:
            if header_name not in mime_obj:
                continue
            for header in mime_obj.get_all(header_name, []):
                header_value = get_header(header)
                if not header_value:
                    continue
                matched_rules += search(rules, header_value)
        return matched_rules

    def _parse_rules(self, policy):
        config = copy.deepcopy(policy)
        rules = []
        for config_data in config.values():
            if not config_data:
                continue
            config_rules = config_data.get('rules') or []
            if not isinstance(config_rules, list):
                raise InvalidRecipientPolicy('Bad search type')
            for rule in config_rules:
                enabled = rule.get('enabled', True)
                if not enabled:
                    continue
                templates = rule.get('templates') or []
                self._parse_templates(templates)
                excluded = rule.get('excluded_templates') or []
                self._parse_templates(excluded)
                rules.append(rule)
        return rules

    @staticmethod
    def _parse_templates(templates):
        for item in templates:
            kind = item.get('kind', 'phrase')
            template = item.get('template', '')
            if kind == 'regex':
                try:
                    item['template'] = re.compile(template)
                except re.error as e:
                    raise InvalidRecipientPolicy('Bad regex: ' + str(e))
            elif kind == 'phrase':
                item['template'] = template.lower()
