from aes.lib import ip_match
from aes.message import MessageInfo, SkipFlags
from aes.engines.mailflow import MailFlowEngine, MailFlowResult
from aes.filters.base import BaseEngineFilter


class ExternalMessageCheck(BaseEngineFilter):
    engine_class = MailFlowEngine

    @staticmethod
    def customer_internal(message: MessageInfo):
        if message.x_from:
            from_domain = message.x_from.split('@')[-1]
            if from_domain not in message.policy.domains:
                return False
        if not message.domain_from:
            return False
        if message.domain_from not in message.policy.domains:
            return False  # for inbound
        if message.domain_to not in message.policy.domains:
            return False  # for outbound
        return True

    def get_external(self, message: MessageInfo):
        mail_flow_result = self.engine_response(message)
        if not self.customer_internal(message):
            return True
        if mail_flow_result['result'] == MailFlowResult.INTERNAL:
            return False
        elif mail_flow_result['result'] == MailFlowResult.EXTERNAL:
            trusted_hosts = message.policy.trusted_hosts
            if ip_match(message.envelope.source_ip, trusted_hosts):
                return False
        return True

    async def process(self, message: MessageInfo, policy=None):
        message.external = self.get_external(message)
        if not message.external:
            message.skip_filters |= SkipFlags.PHISHING
        return 'external' if message.external else 'internal'
