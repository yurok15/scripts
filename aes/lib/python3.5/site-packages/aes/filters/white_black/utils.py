from typing import List
from ipaddress import ip_address, ip_network

from aes.message.info import MessageInfo
from aes.core.sentry import sentry_client
from aes.lib import match, is_ip


def check(emails: List[str], ip: str, template):
    """
    Check given emails and ip match given template.
    """
    template = template.lower()
    if '@' in template:
        return email_match(template, emails)

    if '/' in template:
        return network_match(template, ip)

    if ip and is_ip(template):
        return match(ip, template)
    return domain_match(template, emails)


def email_match(exp, emails):
    for email in emails:
        if match(email, exp):
            return True
    return False


def domain_match(exp, emails):
    for email in emails:
        if match(email.split('@')[-1], exp):
            return True
    return False


def network_match(exp, ip):
    if not ip:
        return False
    try:
        return ip_address(ip) in ip_network(exp)
    except ValueError:
        sentry_client.captureException()
        return False


def get_matching(message: MessageInfo):
    emails = []
    matching = ['envelope_from', 'header_from', 'envelope_to', 'header_to']
    account_settings = message.account_settings.get('white_black', {})
    if account_settings is not None:
        config = account_settings.get('matching', None)
        if config is not None:
            matching = config
    if message.inbound:
        if 'envelope_from' in matching:
            emails.append(message.mail_from.lower())
        if 'header_from' in matching and message.x_from:
            emails.append(message.x_from)
    else:
        if 'envelope_to' in matching:
            emails.append(message.mail_to.lower())
        if 'header_to' in matching and message.x_to:
            for addr in message.x_to:
                emails.append(addr)
    source_ip = str(message.envelope.source_ip) if message.inbound else None
    return emails, source_ip
