import logging

from aes.core.statistics import prometheus
from aes.message import MessageInfo, Category, SkipFlags
from aes.engines.mailflow import MailFlowEngine, MailFlowResult
from aes.filters.base import BaseEngineFilter
from aes.lib import match
from .base_actions import (
    PassAction,
    AddSubject,
    AddHeader,
    QuarantineDelivery,
    AdminQuarantineDelivery,
    UserQuarantineDelivery,
    DenyDelivery,
)

logger = logging.getLogger(__name__)


class TLSCheckFilter(BaseEngineFilter):
    """ Check given email received by encrypted connection """

    actions = {
        'bypass': PassAction(),
        'add_subject': AddSubject('[ TLS FAILED ]'),
        'add_header': AddHeader(),
        'admin_quarantine': AdminQuarantineDelivery(
            'TLS_check_failed', Category.ENFORCE_TLS),
        'user_quarantine': UserQuarantineDelivery(
            'TLS_check_failed', Category.ENFORCE_TLS),
        'quarantine': QuarantineDelivery(
            'TLS_check_failed', Category.ENFORCE_TLS),
        'deny_delivery': DenyDelivery('TLS check_failed', Category.ENFORCE_TLS),
    }
    skip_flag = SkipFlags.TLS_CHECK
    allow_multiple_policy = False
    engine_class = MailFlowEngine

    @prometheus('aes_filters_tls_check')
    async def process(self, message: MessageInfo, tls_check=None):
        """
        "tls_check":
        {
            "rules":
             [
                {
                    "name": "string",
                    "domains":
                    [
                        {
                            "domain_name": "string",
                            "validate_ca": true
                        }
                    ],
                    "actions": [
                        {
                            "name": "string",
                            ...
                        }
                    ]
                },
            ]
        }
        """
        response = self.engine_response(message)

        if response['result'] == MailFlowResult.INTERNAL:
            return
        gate_record = message.envelope.gate_record or {}
        tls_data = gate_record.get('tls')

        rules = tls_check.get('rules', [])
        if isinstance(rules, dict):
            rules = [rules]
        for rule in rules:
            actions = rule.get('actions', None)
            domains = rule.get('domains', None)
            if not actions or not domains:
                continue

            for domain_rec in domains:
                domain_name = domain_rec.get('domain_name', '')
                validate_ca = domain_rec.get('validate_ca', False)
                if match(message.domain_from, domain_name):
                    if tls_data and not validate_ca:
                        logger.info(
                            'Received with %s, certificate not verified',
                            tls_data['details']['version'])
                        return
                    elif tls_data and validate_ca and tls_data['cert_verify']:
                        logger.info(
                            'Received with %s, certificate verified',
                            tls_data['details']['version'])
                        return
                    else:
                        for action_conf in actions:
                            logger.warning('Received without TLS')
                            self.apply_action(message, **action_conf)
