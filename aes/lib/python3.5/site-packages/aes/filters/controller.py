import logging
from collections import OrderedDict

from aes.core.sentry import sentry_client
from aes.message import MessageInfo
from aes.core.controller import BaseController
from aes.filters.exceptions import BaseFiltersException
from aes.engines.controller import EnginesController
from .base import BaseFilter

logger = logging.getLogger(__name__)


class FilterController(BaseController):
    base_class = BaseFilter

    def __init__(self, name, controller, config, loop):
        self.engines = None
        config = config or controller.settings['FILTERS']
        if isinstance(config, (list, tuple)):
            config = OrderedDict(config)
        super(FilterController, self).__init__(
            name, controller, config, loop)

    def requires(self, engines: EnginesController):
        self.engines = engines

    async def _run_multi_policy(self, mail_filter: BaseFilter,
                                message: MessageInfo):
        if mail_filter.skip_flag & message.skip_filters:
            return 'skipped'
        kwargs = {}
        # If filters will have only one category, then need to remove this cycle
        # and refactor other code for multicategory filters
        for category in mail_filter.categories:
            category_conf = OrderedDict()
            for policy_name, policy in message.policy.filtering.items():
                category_conf[policy_name] = policy.get(category)
            kwargs[category] = category_conf
        logger.debug(
            "Start filter %s", mail_filter.name,
            extra={'config': str(kwargs)}
        )
        return await mail_filter.process(message, **kwargs)

    async def _run_simple_policy(self, mail_filter: BaseFilter,
                                 message: MessageInfo):
        results = []
        for policy_name, policy in message.policy.filtering.items():
            # for case upper lever says to skip bottom
            # level policy, check one more time
            if mail_filter.skip_flag & message.skip_filters:
                return 'skipped'
            kwargs = {}
            for category in mail_filter.categories:
                category_conf = policy.get(category)
                if (isinstance(category_conf, dict)
                        and category_conf.get('disabled', False)):
                    category_conf = None
                kwargs[category] = category_conf

            if all(config is None for config in kwargs.values()):
                continue
            logger.debug(
                "Start filter %s (%s)", mail_filter.name, policy_name,
                extra={'config': str(kwargs)}
            )
            result = await mail_filter.process(message, **kwargs)
            if result:
                results.append(result)
        return ', '.join(results)

    async def apply(self, message: MessageInfo):
        """ Apply filters to message with recipient policy """
        logger.info('Start process message')
        for name, mail_filter in self.services.items():
            with message.time('filter_' + name):
                try:
                    if (mail_filter.allow_multiple_policy or
                            not mail_filter.categories):
                        result = await self._run_multi_policy(
                            mail_filter, message)
                    else:
                        result = await self._run_simple_policy(
                            mail_filter, message)
                except BaseFiltersException as e:
                    message.filter_reports[name] = e.reason
                    message.blocked_filter = mail_filter
                    message.category = e.category
                    message.exception = e
                    return
                except Exception as err:
                    logger.exception(
                        'Filter %s failed with error %s', name, err
                    )
                    err.args += (mail_filter.__module__, )
                    err.sentry_id = sentry_client.captureException()
                    message.filter_reports[name] = 'exception'
                    raise
                else:
                    message.filter_reports[name] = result or 'passed'
                    logger.debug(
                        'Filter passed', extra={'filter_name': name}
                    )
