import logging
from operator import itemgetter

from aes.message import MessageInfo, Category, SkipFlags
from aes.core.exceptions import ImproperlyConfigured
from aes.filters.base import BaseFilter
from aes.engines import (
    VadeRetroEngine,
    CloudmarkEngine,
)
from aes.filters.base_actions import (
    AddSubject,
    DenyDelivery,
    AddSpamHeader,
    QuarantineDelivery,
    AdminQuarantineDelivery,
    UserQuarantineDelivery,
)


logger = logging.getLogger(__name__)


class SpamFilter(BaseFilter):
    allow_multiple_policy = True
    actions = {
        'deny_delivery': DenyDelivery('spam', Category.SPAM),
        'add_subject': AddSubject(prefix='[ SPAM ]'),
        'add_spam_subject': AddSubject(Category.SPAM),
        'add_spam_header': AddSpamHeader(Category.SPAM),
        'quarantine': QuarantineDelivery('spam', Category.SPAM),
        'admin_quarantine': AdminQuarantineDelivery('spam', Category.SPAM),
        'user_quarantine': UserQuarantineDelivery('spam', Category.SPAM),
    }
    skip_flag = SkipFlags.SPAM

    def __init__(self, name, controller, config, loop):
        super(SpamFilter, self).__init__(name, controller, config, loop)
        self.vd_engine = None
        self.cm_engine = None

    async def start(self):
        self.vd_engine = self.controller.engines.find_cls(VadeRetroEngine)
        self.cm_engine = self.controller.engines.find_cls(CloudmarkEngine)
        if not self.vd_engine or not self.cm_engine:
            raise ImproperlyConfigured(
                'Spam filter requires both VadeRetro and Cloudmark engines')

    async def process(self, message: MessageInfo, spam=None):
        vd_result = message.envelope.engines[self.vd_engine.name]
        vd_score = vd_result['score']
        category = vd_result['category']
        if category not in self.vd_engine.virus_categories + \
                self.vd_engine.phishing_categories + \
                self.vd_engine.marketing_categories:
            message.email['X-Spam-Category'] = vd_result['category']
            message.email['X-Spam-Reasons'] = vd_result['reasons']
        if category in self.vd_engine.bounce_categories:
            vd_score = 0
        cm_result = message.envelope.engines[self.cm_engine.name]
        cm_score = cm_result['score'] * 100
        score = max(cm_score, vd_score)
        message.spam_score = score
        # backwards compatibility
        message.analytics['x_cmae_analysis'] = cm_result['reasons']
        message.analytics['x_cmae_score'] = cm_result['score']
        message.analytics['x_spam_category'] = vd_result['category']
        message.analytics['x_spam_reasons'] = vd_result['reasons']
        message.analytics['x_spam_score'] = score
        if spam:
            for conf in spam.values():
                if conf:
                    self.process_actions(message, conf, score, category)

    def process_actions(self, message, policy, score, category=None):
        spam_classification = sorted(
            policy.get('classification') or [],
            key=itemgetter('min_score'),
            reverse=True
        )
        for rule in spam_classification:
            if rule['min_score'] <= score:
                for action_conf in rule['actions']:
                    self.apply_action(
                        message, **action_conf, reason='spam')
                return
        logger.debug('Not a spam')
