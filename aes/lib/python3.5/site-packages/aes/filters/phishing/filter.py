import logging
from collections import OrderedDict

from aes.message import MessageInfo, Category, SkipFlags
from aes.engines import VadeRetroEngine
from aes.filters.base import BaseEngineFilter
from aes.filters.base_actions import (
    DenyDelivery,
    QuarantineDelivery,
    AdminQuarantineDelivery,
    UserQuarantineDelivery,
    AddSubject,
    AddSpamHeader,
    AddHeader,
)
from .checkers import checkers


logger = logging.getLogger(__name__)


class PhishingFilter(BaseEngineFilter):

    actions = {
        'deny_delivery': DenyDelivery('phishing', Category.PHISHING),
        'quarantine': QuarantineDelivery('phishing', Category.PHISHING),
        'admin_quarantine':
            AdminQuarantineDelivery('phishing', Category.PHISHING),
        'user_quarantine':
            UserQuarantineDelivery('phishing', Category.PHISHING),
        'add_subject': AddSubject(prefix='[ PHISHING ]'),
        'add_spam_header': AddSpamHeader(),
        'add_header': AddHeader(),
    }
    allow_multiple_policy = False
    skip_flag = SkipFlags.PHISHING
    engine_class = VadeRetroEngine
    matching_levels = {
        0: 80,  # aggressive
        1: 90,  # moderate
        2: 95,  # relaxed
    }

    async def process(self, message: MessageInfo, phishing=None):
        if not phishing or not message.external:
            return

        actions = OrderedDict([
            ('deny_delivery', None),
            ('admin_quarantine', None),
            ('user_quarantine', None),
            ('add_spam_header', None),
            ('add_header', None),
            ('add_subject', None),
            ('add_external_subject', None),
        ])
        reasons = []
        policy = phishing.get('external_messages') or {}
        if policy.get('enabled', True):
            policy.get('actions', [])
            for action in policy.get('actions', []):
                if action.get('name') == 'add_subject':
                    action['subject'] = action.get('subject') or '[ EXTERNAL ]'
                    actions['add_external_subject'] = action

        for section, checker in checkers.items():
            policy = phishing.get(section) or {}
            if policy and policy.get('enabled', True):
                result = checker(policy, message, self)
                if not result:
                    continue
                reasons.append(result)
                self.add_actions(actions, policy)

        log_msg = ', '.join(reasons)
        for name, action_conf in actions.items():
            if action_conf:
                self.apply_action(
                    message, reason=log_msg, **action_conf)
                if name in ['add_spam_header', 'add_header']:
                    break
        return log_msg

    @staticmethod
    def add_actions(actions: dict, policy: dict):
        for action in policy.get('actions', []):
            action_name = action.get('name')
            if action_name in actions:
                actions[action_name] = action
            elif action_name == 'quarantine':
                if action.get('quarantine_type') == 'UserQuarantine':
                    actions['user_quarantine'] = action
                else:
                    actions['admin_quarantine'] = action
            else:
                raise NotImplementedError(
                    'Undefined action {action}'.format(action=action))
