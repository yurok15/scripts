import ssl
import logging

from aiosmtplib.smtp import quote_address

from aes.core.exceptions import ImproperlyConfigured
from aes.core.smtp.client import PatchedSMTP, POSTFIX_STR
from aes.message import MessageInfo
from .base import DeliveryService

logger = logging.getLogger(__name__)


class BaseSMTPDeliveryService(DeliveryService):
    def __init__(self, name, controller, config, loop):
        super(BaseSMTPDeliveryService, self).__init__(
            name, controller, config, loop)
        self.command_encoding = config.get('command_encoding')
        self.ssl_config = config.get('ssl')
        self.tls_config = config.get('starttls')
        if self.ssl_config and self.tls_config:
            raise ImproperlyConfigured(
                'Cant setup SSL and STARTTLS for delivery %s' % name)
        self.ssl_context = self.ssl_context_from_dict(self.ssl_config)
        self.tls_context = self.ssl_context_from_dict(self.tls_config)

    async def _send(self, host, port, mail_from, mail_to, data, analytics=None):
        """
        Send message via SMTP protocol
        :param str host: SMTP host
        :param int port: SMTP port
        :param str mail_from: Mail sender
        :param list mail_to: Mail recipient
        :param bytes data: Mail message
        :return: dict: Route, message was delivered
        """
        server = PatchedSMTP(
            hostname=host,
            port=port,
            loop=self.loop,
            default_8bit_encoding=self.command_encoding,
            tls_context=self.tls_context
        )
        try:
            assert isinstance(mail_to, list)
            assert isinstance(data, bytes)
            mail_from = bytes(quote_address(mail_from), encoding='utf-8')
            mail_to = [bytes(quote_address(address), encoding='utf-8') for
                       address in mail_to]
            await server.connect(ssl=self.ssl_context)
            _, response = await server.sendmail(mail_from, mail_to, data,
                                                analytics=analytics)
            report = {'host': host, 'port': port}
            pos = response.find('queued as')
            if pos >= 0:
                pos += len(POSTFIX_STR)
                report['postfix_queue_id'] = response[pos:]
            await server.quit()
            return report
        except BaseException:
            await server.close()
            raise

    @staticmethod
    def ssl_context_from_dict(config):
        if config is None:
            return None
        verify = config.get('verify', True)
        check_hostname = config.get('check_hostname', True)
        cafile = config.get('cafile') or None

        ssl_context = ssl.create_default_context(
            ssl.Purpose.SERVER_AUTH,
            cafile=cafile if verify else None
        )
        ssl_context.check_hostname = verify and check_hostname
        if not verify:
            ssl_context.verify_mode = ssl.CERT_NONE
        return ssl_context


class BaseRouteDelivery(BaseSMTPDeliveryService):
    def __init__(self, name, controller, config, loop):
        super(BaseRouteDelivery, self).__init__(
            name, controller, config, loop)
        self.raw_data = config.get('raw_data', False)

    async def send(self, msg, mail_from, mail_to, data):
        """ Send message to preconfigured SMTP server """
        host, port = await self.get_endpoint(msg)
        return await self._send(
            host,
            port,
            mail_from,
            mail_to,
            data,
            analytics=msg.analytics)

    def _get_data(self, msg: MessageInfo):
        return msg.serialize(self.raw_data)

    async def process(self, msg: MessageInfo):
        msg.log_delivery(
            self.name,
            await self.send(
                msg,
                msg.mail_from,
                [msg.mail_to],
                self._get_data(msg),
            )
        )

    async def get_endpoint(self, msg):
        raise NotImplementedError
