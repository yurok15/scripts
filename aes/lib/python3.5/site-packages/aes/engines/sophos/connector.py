import logging

from aes.core.sentry import sentry_client
from aes.core.statistics import prometheus
from aes.lib.chat.protocol import BaseChatProtocol
from aes.lib.chat.connector import BaseTCPConnector, BaseNetworkConnector


logger = logging.getLogger(__name__)


class SophosProtocolException(Exception):
    pass


class SophosScanException(Exception):
    pass


class SophosCriticalException(Exception):
    pass


sophos_reconnects_counter = prometheus.counter('sophos_reconnects')
sophos_warnings_counter = prometheus.counter('sophos_warnings')

CORRUPTED_FILE = 'Scan could not proceed due to a corrupted file or sub-file'


class SophosProtocol(BaseChatProtocol):
    default_encoding = 'utf-8'
    default_line_separator = b'\r\n'

    async def handle_client(self, reader, writer):
        response = await reader.read_line()
        if response != 'OK SSSP/1.0':
            self.close()
            raise SophosProtocolException('Invalid hello string')
        await writer.write_line('SSSP/1.0')
        await self._read_acc()
        await super(SophosProtocol, self).handle_client(reader, writer)

    @staticmethod
    def _split(line):
        words = line.split(' ', maxsplit=1)
        if len(words) < 2:
            raise SophosProtocolException('Invalid answer', line)
        return words

    async def _read_acc(self):
        response = await self._stream_reader.read_line()
        answer, _ = self._split(response)
        if answer != 'ACC':
            raise SophosProtocolException(response)

    async def scan(self, data: bytes, ignore_errors: list, scan_errors: list):
        # for case when connection closed, but all needed data was readed.
        # stream_reader link will be None, but reader itself will have data in
        # it
        reader = self._stream_reader
        await self._stream_writer.write_line('SCANDATA %d' % len(data))
        self._stream_writer.write(data)
        await self._read_acc()
        response = await reader.read_line(b'\r\n\r\n')
        lines = (self._split(line) for line in response.split('\r\n'))
        answer = {key: value for key, value in lines}
        if 'DONE' not in answer:
            raise SophosProtocolException(response)
        done_string = answer['DONE'].split(' ', maxsplit=2)
        if len(done_string) != 3:
            raise SophosProtocolException(answer['DONE'])
        if done_string[0] == 'FAIL' and done_string[1] in ignore_errors:
            return None
        if done_string[0] == 'FAIL' and done_string[1] in scan_errors:
            raise SophosScanException(answer['DONE'])
        if done_string[0] != 'OK':
            raise SophosCriticalException(answer['DONE'])
        if done_string[1] not in ['0203', '0000']:
            sentry_client.captureMessage(
                'Sophos warning', extra={'answer': answer['DONE']}
            )
            logger.warning('Sophos warning: %s', answer['DONE'])
            sophos_warnings_counter.inc()
        return answer.get('VIRUS')

    async def version(self):
        reader = self._stream_reader
        await self._stream_writer.write_line('QUERY ENGINE')
        await self._read_acc()
        response = await reader.read_line(b'\r\n\r\n')
        response = response.splitlines()
        data = {}
        for line in response:
            name, value = line.split(': ', 1)
            data[name] = value
        return 'sav: %s, engine: %s' % (
            data.get('savversion'), data.get('engineversion'))


class BaseSophosConnector(BaseNetworkConnector):
    protocol_cls = SophosProtocol
    retry_exceptions = SophosProtocolException, SophosCriticalException

    def __init__(self, loop, ignore_errors=None, scan_errors=None, **kwargs):
        super(BaseSophosConnector, self).__init__(loop, **kwargs)
        self.ignore_errors = ignore_errors or []
        self.scan_errors = scan_errors or []

    async def reconnect(self):
        sophos_reconnects_counter.inc()
        await super(BaseSophosConnector, self).reconnect()

    @BaseNetworkConnector.retry_connect
    async def check(self, buff):
        return await self.protocol.scan(
            buff, self.ignore_errors, self.scan_errors)

    @BaseNetworkConnector.retry_connect
    async def version(self):
        return await self.protocol.version()

    async def open_connection(self):
        raise NotImplementedError()


class SophosNetworkSocket(BaseTCPConnector, BaseSophosConnector):
    default_port = 3310

    def _connect_str(self):
        return "{host}:{port}".format(host=self.host, port=self.port)
