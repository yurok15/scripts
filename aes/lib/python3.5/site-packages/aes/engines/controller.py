import asyncio
import logging
import time
from email.parser import Parser

from aes.core.sentry import sentry_client
from aes.core.controller import BaseController
from aes.core.smtp.protocol import AESEnvelope
from aes.message import FixedMessage, TIME_MULTI
from aes.lib import make_hash
from aes.lib.mime import (
    fix_missed_headers_after_received,
    ReceivedHeaderDefect,
)
from .base import BaseEngineService, BasePoolEngine

logger = logging.getLogger(__name__)


class EnginesController(BaseController):
    base_class = BaseEngineService

    def __init__(self, name, controller, config, loop):
        config = controller.settings['ENGINES'] if config is None else config
        super(EnginesController, self).__init__(
            name, controller, config, loop)

    async def apply_engine(self, service: BaseEngineService,
                           envelope: AESEnvelope):
        response = {}
        start = time.time()
        try:
            response = await service.process(envelope)
        except BaseException as error:
            response['exception'] = str(error)
            raise
        finally:
            t = time.time() - start
            response['time'] = t * TIME_MULTI
            envelope.engines[service.name] = response

    @staticmethod
    def _parse_message(envelope: AESEnvelope, headers_only=False):
        return Parser(_class=FixedMessage).parsestr(
            envelope.content, headersonly=headers_only)

    def parse_headers(self, envelope: AESEnvelope):
        envelope.content = envelope.original_content.decode(
            'ASCII', errors='surrogateescape')
        msg = self._parse_message(envelope, True)
        if all((h[0] == 'Received' for h in msg._headers)):
            raw_msg, fixed = fix_missed_headers_after_received(
                envelope.content)
            if fixed:
                envelope.content = raw_msg
                msg = self._parse_message(envelope, True)
                envelope.defects.append(ReceivedHeaderDefect())
        envelope.email = msg

    async def process(self, envelope: AESEnvelope):
        if envelope.hash is None:
            envelope.hash = make_hash(envelope.original_content)
        self.parse_headers(envelope)
        envelope.engines = {}
        tasks = []
        tasks_by_engine = {}
        for service in self.services.values():
            task = self.loop.create_task(
                self.apply_engine(service, envelope))
            tasks.append(task)
            tasks_by_engine[service] = task
        if tasks:
            await asyncio.wait(tasks, loop=self.loop)
        for service, task in tasks_by_engine.items():
            try:
                task.result()
            except Exception as err:
                err.args += (service.__module__,)
                raise

    async def versions(self) -> dict:
        response = {}
        for name, mail_filter in self.services.items():
            try:
                version = await mail_filter.version()
                if version:
                    response[name] = version
            except Exception as e:
                sentry_client.captureException()
                logger.exception(e)
                response[name] = '(%s) %s' % (e.__class__.__name__, str(e))
        return response

    def pool_report(self) -> dict:
        response = {}
        for name, mail_filter in self.services.items():
            if isinstance(mail_filter, BasePoolEngine):
                response[name] = mail_filter.pool.report()
        return response
