from asyncio.streams import IncompleteReadError
import re

from aes.core.statistics import prometheus
from aes.lib.chat.protocol import BaseChatProtocol
from aes.lib.connection_pool import ConnectorRecoverableException
from aes.lib.chat.connector import BaseNetworkConnector, BaseTCPConnector


class VadeRetroError(ConnectorRecoverableException):
    """ Base VadeRetro error."""


class VadeRetroProtocolError(VadeRetroError):
    """ Error while parsing VadeRetro response"""


class VadeRetroRemoteError(VadeRetroError):
    """ Error send by VadeRetro """

vd_reconnects_counter = prometheus.counter('vaderetro_reconnects')


class VadeRetroProtocol(BaseChatProtocol):
    default_encoding = 'latin1'
    default_line_separator = b'\r\n'

    async def execute(self, command, long=False):
        await self._stream_writer.write_line(
            command,
            encoding='utf-8',
            separator=b'\r\n.\r\n' if long else b'\r\n'
        )
        return await self._stream_reader.read_line()

    async def version(self):
        status_str = await self.execute('VERSION')
        if not status_str.startswith('VERSION: '):
            raise VadeRetroProtocolError(status_str)
        status_str = status_str.replace('VERSION: ', '')
        if status_str[:3] != 'OK,':
            raise VadeRetroRemoteError(status_str)
        status_str = status_str.replace('OK,', '')
        return status_str

    async def vrscanb(self, body):
        response = await self.execute('VRSCANB')
        if not((len(response) > 2) and (response[:2] == 'OK')):
            raise VadeRetroRemoteError(response)
        body = re.sub(rb'(?:\r\n|\n|\r(?!\n))', b'\r\n', body)
        body = re.sub(rb'(?m)^\.', b'..', body)  # quote periods
        response = await self.execute(body, long=True)
        response = re.sub('[\r\n\x1e]', '', response)
        response = response.split('\t')
        status_str = response.pop(0)
        if not status_str.startswith('VRSCANB: '):
            raise VadeRetroProtocolError(status_str)
        status_str = status_str.replace('VRSCANB: ', '')
        if status_str[:3] != 'OK,':
            raise VadeRetroRemoteError(status_str)
        status_str = status_str.replace('OK,', '')
        if not status_str.startswith('State='):
            raise VadeRetroProtocolError('No state in response')
        try:
            state = int(status_str.replace('State=', ''))
        except:
            raise VadeRetroProtocolError(status_str)
        if not response:
            raise VadeRetroProtocolError('No score in response')
        score_data = response.pop(0)
        if not score_data.startswith('Score='):
            raise VadeRetroProtocolError(score_data)
        try:
            score = int(score_data.replace('Score=', ''))
        except:
            raise VadeRetroProtocolError(score_data)
        tests = '\t'.join(response)
        return score, state, tests


class BaseVadeRetroConnector(BaseNetworkConnector):
    protocol_cls = VadeRetroProtocol
    retry_exceptions = (ConnectionResetError, IncompleteReadError)

    async def reconnect(self):
        vd_reconnects_counter.inc()
        await super(BaseVadeRetroConnector, self).reconnect()

    @BaseNetworkConnector.retry_connect
    async def get_score(self, data):
        return await self.protocol.vrscanb(data)

    @BaseNetworkConnector.retry_connect
    async def version(self):
        return await self.protocol.version()

    async def open_connection(self):
        raise NotImplementedError()


class VadeRetroConnector(BaseTCPConnector, BaseVadeRetroConnector):
    pass
