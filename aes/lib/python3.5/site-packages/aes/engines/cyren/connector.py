import asyncio
import uuid
from aes.lib.chat.connector import BaseHTTPConnector


class CyrenWrongResponse(Exception):
    pass


class CyrenAnalysis:
    def __init__(self, headers):
        if 'X-CTCH-AV-ThreatsCount' not in headers:
            raise CyrenWrongResponse('No threats response header')
        try:
            self.threats_count = int(headers['X-CTCH-AV-ThreatsCount'])
        except ValueError:
            raise CyrenWrongResponse('Invalid threats header')
        self.vod = headers.get('X-CTCH-VOD')
        self.reason = headers.get('X-CTCH-RefID')
        spam_score = headers.get('X-CTCH-Score')
        self.spam_score = float(spam_score) if spam_score else 0
        self.spam_category = headers.get('X-CTCH-Spam')
        self.av_accuracy = headers.get('X-CTCH-AV-DetectionAccuracy')
        self.av_name = headers.get('X-CTCH-AV-DetectionName')
        self.av_type = headers.get('X-CTCH-AV-DetectionType')

    @property
    def virus(self):
        if not self.threats_count:
            return None
        return '({accuracy}){virus_type}:{name}'.format(
            accuracy=self.av_accuracy,
            virus_type=self.av_type,
            name=self.av_name
        )


class SpamConnector(BaseHTTPConnector):
    def __init__(self, loop, host, port, retry_attempts, timeout=60,
                 spam_support=True):
        super(SpamConnector, self).__init__(loop, retry_attempts)
        self.host = host
        self.port = port
        self.timeout = timeout
        self.spam_support = spam_support

    @BaseHTTPConnector.retry_connect
    async def _make_request(self, uri, data):
        url = 'http://{host}:{port}{uri}'.format(
            host=self.host, port=self.port, uri=uri
        )

        session = self.protocol
        headers = {}
        async with session.post(url, allow_redirects=False, data=data) as resp:
            text = await resp.text()
            if resp.status != 200:
                raise CyrenWrongResponse(text)
            text = text.split('\r\n')
            headers_data = [v.split(': ', maxsplit=1) for v in text if v]
            for header_data in headers_data:
                if len(header_data) != 2:
                    raise CyrenWrongResponse(
                        'Invalid header: ' + str(header_data)
                    )
                headers[header_data[0]] = header_data[1]
        return headers

    async def check_message(self, raw_data: bytes, source_ip=None,
                            mail_from=None) -> CyrenAnalysis:
        data = "X-CTCH-PVer:0000001\r\n"
        if self.spam_support:
            if source_ip:
                data += "X-CTCH-SenderIP: {ip}\r\n".format(ip=str(source_ip))
            if mail_from:
                data += "X-CTCH-MailFrom: {email}\r\n".format(email=mail_from)
            url = '/ctasd/ClassifyMessage_Inline'
        else:
            data += "X-CTCH-FileName: %s.bin\r\n" % uuid.uuid4()
            url = '/ctasd/ClassifyObject_Inline'
        data = bytes(data, encoding='utf-8') + b'\r\n' + raw_data
        headers = await asyncio.wait_for(
            self._make_request(url, data),
            loop=self.loop,
            timeout=self.timeout,
        )
        return CyrenAnalysis(headers)

    async def version(self):
        data = "X-CTCH-PVer:0000001\r\n"
        url = '/ctasd/GetServices'
        headers = await asyncio.wait_for(
            self._make_request(url, data),
            loop=self.loop,
            timeout=self.timeout,
        )
        number = int(headers['X-CTCH-Services'])
        possible_services = [
            ('AV', 64),
            ('CustomCategory', 32),
            ('IpRep', 16),
            ('OutboundSpam', 8),
            ('WebSec', 4),
            ('VOD', 2),
            ('AntiSpam', 1),
        ]
        services = []
        for name, value in possible_services:
            if number >= value:
                number -= value
                services.append(name)
        return ', '.join(services)
