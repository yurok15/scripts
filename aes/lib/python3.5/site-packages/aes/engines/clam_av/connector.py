import asyncio
from io import BytesIO
import re
import struct
from aes.core.statistics import prometheus
from aes.lib.chat.protocol import BaseChatProtocol, DEFAULT_LIMIT
from aes.lib.chat.connector import (
    BaseTCPConnector,
    BaseUnixConnector,
    BaseNetworkConnector,
)

scan_response = re.compile(
    r'^(?P<path>.*): ((?P<virus>.+) )?(?P<status>(FOUND|OK|ERROR))$'
)

clamav_reconnects_counter = prometheus.counter('clamav_reconnects')


class ClamdResponseError(Exception):
    pass


class BufferTooLongError(ClamdResponseError):
    """Class for errors with clamd using INSTREAM with a
    buffer lenght > StreamMaxLength in /etc/clamav/clamd.conf"""


class ClamdProtocol(BaseChatProtocol):
    default_encoding = 'utf-8'
    command_number = 0
    number_separator = ': '

    def __init__(self, loop, timeout=15, limit=DEFAULT_LIMIT,
                 max_chunk_size=1024 * 1024):
        super(ClamdProtocol, self).__init__(loop, timeout=timeout, limit=limit)
        self.max_chunk_size = max_chunk_size

    async def handle_client(self, reader, writer):
        await self._send_command('IDSESSION')
        self.command_number = 0
        await super(ClamdProtocol, self).handle_client(reader, writer)

    async def ping(self):
        return await self._basic_command("PING")

    async def version(self):
        return await self._basic_command("VERSION")

    async def scan(self, file):
        return await self._file_system_scan('SCAN', file)

    async def _basic_command(self, command):
        """
        Send a command to the clamav server, and return the reply.
        """
        await self._send_command(command)
        response = await self._recv_response()
        response = response.rsplit("ERROR", 1)
        if len(response) > 1:
            raise ClamdResponseError(response[0])
        else:
            return response[0]

    async def _file_system_scan(self, command, file):
        """
        Scan a file or directory given by filename using multiple threads
        (faster on SMP machines).
        Do not stop on error or virus found.
        Scan with archive support enabled.

        file (string): filename or directory (MUST BE ABSOLUTE PATH !)

        return:
          - (dict): {filename1: ('FOUND', 'virusname'),
           filename2: ('ERROR', 'reason')}

        May raise:
          - ConnectionError: in case of communication problem
        """

        await self._send_command(command, file)

        dr = {}
        data = await self._recv_response()
        filename, reason, status = self._parse_response(data)
        dr[filename] = (status, reason)
        return dr

    async def instream(self, buff):
        """
        MUST be < StreamMaxLength in /etc/clamav/clamd.conf

        Scan a buffer

        buff  filelikeobj: buffer to scan

        return:
          - (dict): {filename1: ("virusname", "status")}

        May raise :
          - BufferTooLongError: if the buffer size exceeds clamd limits
          - ConnectionError: in case of communication problem
        """
        await self._send_command('INSTREAM')

        chunk = buff.read(self.max_chunk_size)
        try:
            while chunk:
                size = struct.pack(b'!L', len(chunk))
                self._stream_writer.write(size + chunk)
                chunk = buff.read(self.max_chunk_size)
                await self._stream_writer.drain()
            self._stream_writer.write(struct.pack(b'!L', 0))

        except ConnectionResetError:
            result = self._pull_response()

        else:
            result = await self._recv_response()

        if len(result) > 0:
            if result == 'INSTREAM size limit exceeded. ERROR':
                raise BufferTooLongError(result)

            _, signature, result = self._parse_response(result)
            if result not in ['OK', 'FOUND']:
                raise ClamdResponseError(result)
            return signature if result == 'FOUND' else None

    async def stats(self):
        """
        Get Clamscan stats

        return: (string) clamscan stats

        May raise:
          - ConnectionError: in case of communication problem
        """
        await self._send_command('STATS')
        data = await asyncio.wait_for(
            self._stream_reader.readuntil(b'\nEND\n'),
            timeout=self._timeout,
            loop=self._loop,
        )
        return str(data, encoding=self.default_encoding)

    async def _send_command(self, cmd, *args):
        """
        `man clamd` recommends to prefix commands with z, but we will use \n
        terminated strings, as python<->clamd has some problems with \0x00
        """
        concat_args = ''
        if args:
            concat_args = ' ' + ' '.join(args)

        cmd = 'n{cmd}{args}\n'.format(cmd=cmd,
                                      args=concat_args).encode('utf-8')
        self._stream_writer.write(cmd)
        await self._stream_writer.drain()

    async def _recv_response(self):
        """
        receive line from clamd
        """
        data = await self._stream_reader.read_line()
        return self._get_response(data)

    def _pull_response(self):
        """
        pull response from reader buffer
        """
        data = self._get_reader_buffer()
        return self._get_response(data)

    def _get_response(self, data):
        pos = data.find(self.number_separator)
        if pos:
            number = data[:pos]
            response = data[pos + len(self.number_separator):]
            try:
                number = int(number)
            except ValueError:
                self.logger.error('Invalid response number: %s', number)
            else:
                if not self._check_command_number(number):
                    self.logger.error('Wrong response number: %s vs %s',
                                      number, self.command_number)
            return response

    def _check_command_number(self, number):
        self.command_number += 1
        return self.command_number == number

    @staticmethod
    def _parse_response(msg):
        """
        parses responses for SCAN, CONTSCAN, MULTISCAN and STREAM commands.
        """
        try:
            return scan_response.match(msg).group("path", "virus", "status")
        except AttributeError:
            raise ClamdResponseError(msg.rsplit("ERROR", 1)[0])


class BaseClamdConnector(BaseNetworkConnector):
    protocol_cls = ClamdProtocol

    async def reconnect(self):
        clamav_reconnects_counter.inc()
        await super(BaseClamdConnector, self).reconnect()

    @BaseNetworkConnector.retry_connect
    async def version(self):
        return await self.protocol.version()

    @BaseNetworkConnector.retry_connect
    async def check(self, buff):
        return await self.protocol.instream(BytesIO(buff))

    async def open_connection(self):
        raise NotImplementedError()


class ClamdNetworkSocket(BaseTCPConnector, BaseClamdConnector):
    default_port = 3310


class ClamdUnixSocket(BaseUnixConnector, BaseClamdConnector):
    default_unix_path = '/var/run/clamav/clamd.ctl'
