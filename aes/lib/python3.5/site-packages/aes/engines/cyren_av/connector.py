import struct
import logging

from aes.core.statistics import prometheus
from aes.lib.chat.connector import BaseTCPConnector, BaseUnixConnector
from aes.engines.clam_av.connector import (
    ClamdProtocol,
    BaseClamdConnector,
)

logger = logging.getLogger(__name__)

cyren_reconnects_counter = prometheus.counter('cyren_reconnects')


class CyrenError(Exception):
    pass


class CyrenResponseError(CyrenError):
    pass


class CyrenInputClobberedError(CyrenError):
    pass


class BufferTooLongError(CyrenResponseError):
    """Class for errors with cyren using INSTREAM with a
    buffer length """


class CyrenProtocol(ClamdProtocol):
    default_encoding = 'utf-8'
    command_number = 0
    number_separator = ':'

    async def handle_client(self, reader, writer):
        await writer.write_line('IDSESSION')
        result = await self._recv_response()
        if result != 'OK':
            raise CyrenError(result)
        self.started.set_result(self)

    def _check_command_number(self, number):
        if not self.command_number:
            self.command_number = number
        return number == self.command_number

    async def _file_system_scan(self, command, file):
        await self._send_command(command, file)
        data = await self._recv_response()
        return self._parse_response(data)

    async def stats(self):
        await self._send_command('STATS')
        return await self._recv_response()

    async def version(self):
        await self._send_command('VERSION')
        v = await self._recv_response()
        return v

    async def instream(self, buff):
        await self._send_command('INSTREAM')
        result = await self._recv_response()
        if result != 'OK SEND_DATA':
            if result == 'FAIL INPUT_CLOBBERED':
                raise CyrenInputClobberedError
            raise CyrenError(result)

        chunk = buff.read(self.max_chunk_size)
        while chunk:
            size = struct.pack(b'!L', len(chunk))
            self._stream_writer.write(size + chunk)
            chunk = buff.read(self.max_chunk_size)

        self._stream_writer.write(struct.pack(b'!L', 0))
        await self._stream_writer.drain()
        result = await self._recv_response()
        return self._parse_response(result)

    @staticmethod
    def _parse_response(msg):
        """
        parses responses for SCAN, CONTSCAN, MULTISCAN and STREAM commands.
        """
        words = msg.strip().split(' ')
        status = words.pop(0)
        if status != 'OK' or (not words):
            raise CyrenResponseError(msg)
        status = words.pop(0)
        if status == 'INFECTED':
            if words:
                return (' '.join(words)).strip()
            return 'unknown'
        elif status == 'CLEAN':
            return None
        else:
            logger.warning('Cyren_not_scaned', extra={
                'cyren_status': status,
                'cyren_info': (' '.join(words)).strip(),
            })


class BaseCyrenConnector(BaseClamdConnector):
    protocol_cls = CyrenProtocol
    retry_exceptions = (ConnectionResetError, CyrenInputClobberedError)

    async def reconnect(self):
        cyren_reconnects_counter.inc()
        await super(BaseCyrenConnector, self).reconnect()

    async def open_connection(self):
        raise NotImplementedError()


class CyrenNetworkSocket(BaseTCPConnector, BaseCyrenConnector):
    default_port = 2705


class CyrenUnixSocket(BaseUnixConnector, BaseCyrenConnector):
    default_unix_path = '/var/run/ctch/csamd/csamd.sock'
