import logging
from ipaddress import ip_address, ip_network

from aes.lib import match, ip_match
from aes.lib.utils import get_smtp_chain, get_header
from aes.core.sentry import sentry_client
from aes.core.exceptions import ImproperlyConfigured
from aes.core.smtp.protocol import AESEnvelope
from aes.engines.base import BaseEngineService


logger = logging.getLogger(__name__)


class MailFlowResult:
    EXTERNAL = 'EXTERNAL'
    INTERNAL = 'INTERNAL'
    NON_LEGIT = 'NON_LEGIT'
    ERROR_CONFIGURATION = 'ERROR: NO_CONFIGURATION'


class MailFlowEngine(BaseEngineService):

    def __init__(self, name, controller, config, loop):
        super(MailFlowEngine, self).__init__(name, controller, config, loop)
        self._ip_missed = []
        rules = config.get('source_ip_missed') or \
                config.get('SOURCE_IP_MISSED') or []
        for rule in rules:
            self._ip_missed.append(Rule(rule))
        self._ip_present = []
        rules = config.get('source_ip_present') or \
                config.get('SOURCE_IP_PRESENT') or []
        for rule in rules:
            self._ip_present.append(Rule(rule))
        self.internal_hosts = config.get('internal_hosts') or []

    async def process(self, envelope: AESEnvelope):
        msg = envelope.email
        source_ip = None
        if 'X-SOURCE-IP' not in msg:
            logger.warning('Source IP header missed')
            sentry_client.captureMessage('Source IP header missed')
        else:
            value = get_header(msg['X-SOURCE-IP'])
            try:
                source_ip = ip_address(value)
            except ValueError:
                extra = {'source_ip': value}
                sentry_client.captureMessage(
                    'Invalid source ip address',
                    extra=extra
                )
                logger.warning('Invalid source ip address', extra=extra)
        envelope.source_ip = source_ip
        envelope.chain = get_smtp_chain(msg)
        if not self._ip_present and not self._ip_missed:
            return {'result': MailFlowResult.ERROR_CONFIGURATION}

        if not envelope.source_ip:
            for rule in self._ip_missed:
                if rule.match(envelope.peer[0], envelope.chain,
                              chain_exact_match=True):
                    return {'result': MailFlowResult.INTERNAL}
            return {'result': MailFlowResult.NON_LEGIT}
        for rule in self._ip_present:
            if rule.match(envelope.peer[0], envelope.chain):
                envelope.gate_record = envelope.chain[rule.chain_len - 1] \
                    if envelope.chain else None
                if ip_match(envelope.source_ip, self.internal_hosts):
                    return {'result': MailFlowResult.INTERNAL}
                return {'result': MailFlowResult.EXTERNAL}
        return {'result': MailFlowResult.NON_LEGIT}


class Rule(object):
    """
    Parse and validate rules configuration on initialization.
    Get dict:
        'peer': list of hosts
        'chain': list of hops, hop is list of hosts
    Support IPv4 addresses and networks and domain template (UNIX glob format)
    """

    def __init__(self, conf: dict):
        self.peer = []
        self.chain = []

        if not isinstance(conf['peer'], (list, tuple)):
            raise ImproperlyConfigured(
                'Peers declaration must be array or tuple: %s',
                conf['peer'])
        for host in conf['peer']:
            self.peer.append(self._parse_host(host))

        for hop in conf['chain']:
            if not isinstance(hop, (list, tuple)):
                raise ImproperlyConfigured(
                    'Chain hops declaration must be array or tuple %s',
                    hop)
            parsed_hop = []
            for host in hop:
                parsed_hop.append(self._parse_host(host, fqdn=True))
            self.chain.append(parsed_hop)
        self.chain_len = len(self.chain)

    def match(self, peer, chain, chain_exact_match=False):

        if not self._is_in(self.peer, peer):
            return False
        if chain_exact_match and len(chain) != self.chain_len:
            return False
        if not chain_exact_match and len(chain) < self.chain_len:
            return False
        for hop, hosts in enumerate(self.chain):
            if not self._is_in(hosts, *chain[hop]['by']):
                return False
        return True

    @staticmethod
    def _parse_host(host: str, fqdn=False):
        try:
            return 'ip', ip_address(host)
        except ValueError:
            pass
        try:
            return 'net', ip_network(host)
        except ValueError:
            pass
        if not fqdn and '*' not in host and '?' not in host:
            raise ImproperlyConfigured(
                'Bad host declaration in settings: %s', host)
        return 'fqdn_tt', host

    @staticmethod
    def _is_in(hosts: list, ip_addr, name=None):
        try:
            ip = ip_address(ip_addr)
        except ValueError:
            ip = None
        if name:
            name = name.lower()

        for kind, value in hosts:
            if ip and kind == 'ip':
                if ip == value:
                    return True
            elif ip and kind == 'net':
                if ip in value:
                    return True
            if kind == 'fqdn_tt':
                if ip and match(ip_addr, value):
                    return True
                if name and match(name, value.lower()):
                    return True
                if all(ch == '*' for ch in value):
                    return True
        return False
