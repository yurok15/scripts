import logging
import time
import re
import uuid
from email._parseaddr import AddressList
from email.utils import getaddresses

from aes.core.smtp.protocol import AESEnvelope
from aes.core.statistics import prometheus
from aes.core.analytics import set_user_context, log_attachment
from aes.core.sentry import sentry_client
from aes.lib.mime import get_header
from aes.policy_service.policy import UserPolicy
from .email import FixedMessage
from .attachment import AttachInfo
from .consts import Category, SkipFlags  # , TrackCategory

logger = logging.getLogger(__name__)

TIME_MULTI = 1000
SUBJECT_HEADER_LOG_LEN = 160

defected_messages_counter = prometheus.counter('defected_messages')


class MessageTimingManager:
    def __init__(self, message_info, name):
        """

        :param MessageInfo message_info: message info
        :param str name: timing name
        """
        self.message_info = message_info
        self.name = name
        self.start = time.time()

    def __enter__(self):
        return self

    def __exit__(self, *args):
        t = time.time() - self.start
        if self.name in self.message_info.timings:
            self.message_info.timings[self.name] += t * TIME_MULTI
        else:
            self.message_info.timings[self.name] = t * TIME_MULTI


class MessageInfo:
    def __init__(self, envelope: AESEnvelope, mail_to: str):
        self.envelope = envelope
        self.mail_from = envelope.mail_from.email
        self.mail_to = mail_to
        self.user = mail_to if envelope.inbound else self.mail_from
        self.inbound = envelope.inbound
        self.timings = {}
        self.filter_reports = {}
        self.id = envelope.id
        size = len(envelope.original_content) * 1.0
        self.message_id = str(uuid.uuid4())
        # self.tracking = {
        #     'category': TrackCategory.UNCATEGORISED,
        #     'destination': [],
        #     'errorCode': None,
        #     'handling': [],
        # }
        self.analytics = {
            'm_id': self.message_id,
            'delivery_relay': [],
            'users': [envelope.mail_from.email, mail_to],
            'user': self.user,
            'direction': 'inbound' if self.inbound else 'outbound',
            'timings': self.timings,
            'filters': self.filter_reports,
            'in_size_kb': size / 1024,
            'in_size_mb': size / (1024 * 1024),
            'smtp_peer': envelope.peer[0],
            'source_ip': str(envelope.source_ip),
            'engines': envelope.engines,
            # 'message_tracking': self.tracking,
        }
        self.domain_from = self.mail_from.split('@')[-1].lower()
        self.domain_to = self.mail_to.split('@')[-1].lower()
        set_user_context(
            user=self.user,
            mail_to=self.mail_to,
            mail_from=self.mail_from,
            to_domain=self.domain_to,
            from_domain=self.domain_from,
        )
        self.skips = []
        self.policy = None  # type: UserPolicy
        self.account_settings = {}
        self.email = None
        self.skip_filters = SkipFlags.NOTHING
        self.attachments = []
        self.x_reply_to = None
        self.x_from = None
        self.x_to = None
        self.x_from_display_name = None
        self.exception = None
        self.client_message_id = None
        self._category = None
        self._x_spam_score = None
        self.copy_admin_quarantine = None
        self.copy_user_quarantine = None
        self.blocked_filter = None
        self.subject = ''
        self.silent_copy = []
        self.send_delivery = None
        self.external = None
        self._dropped = []

    @property
    def category(self):
        return self._category

    @category.setter
    def category(self, value):
        if self._category and self._category != Category.LEGIT:
            return
        self._category = value
        self.analytics['x_aes_category'] = value
        while 'X-AES-Category' in self.email:
            del self.email['X-AES-Category']
        self.email['X-AES-Category'] = value

    @property
    def spam_score(self):
        return self._x_spam_score

    @spam_score.setter
    def spam_score(self, value):
        value = int(value)
        self._x_spam_score = value
        self.analytics['x_spam_score'] = value
        while 'X-Spam-Score' in self.email:
            del self.email['X-Spam-Score']
        self.email['X-Spam-Score'] = str(value)

    @property
    def spam_status(self):
        if 'X-Spam-Status' in self.email:
            return True
        return False

    @spam_status.setter
    def spam_status(self, value):
        while 'X-Spam-Status' in self.email:
            del self.email['X-Spam-Status']
        if value:
            self.email['X-Spam-Status'] = value
            self.analytics['x_spam_status'] = True

    def add_header(self, header, value):
        if header == 'X-Spam-Status':
            self.spam_status = value
        else:
            self.email.add_header(header, value)
            field = header.replace('-', '_').lower()
            if field in self.analytics:
                self.analytics[field] = value

    def time(self, name):
        return MessageTimingManager(self, name)

    def _get_email(self, header_name):
        data = get_header(self.email[header_name])
        if not data:
            return data, ''
        try:
            addr_list = AddressList(data)
            name_parts = []
            address = ''
            for name, addr in addr_list.addresslist:
                if '@' in addr:
                    if not address:
                        address = addr.lower()
                        name_parts.append(name.strip())
                else:
                    name_parts.append(addr.strip())
            if address:
                return address, ' '.join(name_parts)
            raise ValueError
        except Exception:
            sentry_client.captureMessage(
                'Invalid email %s' % header_name, extra={'value': data})
            return None, None

    def _process_headers(self):
        msg = self.email
        self.x_from, self.x_from_display_name = self._get_email('From')
        self.x_reply_to, _ = self._get_email('Reply-To')
        try:
            h_values = [str(h) for h in msg.get_all('To', [])]
            self.x_to = [
                addr for name, addr in getaddresses(h_values) if '@' in addr]
        except Exception:
            sentry_client.captureMessage(
                'Invalid email To',
                extra={'to_headers': ', '.join(
                    [get_header(h) for h in msg.get_all('To', [])])})
        self.analytics['x_from'] = self.x_from or ''
        self.analytics['x_to'] = self.x_to or ''
        self.analytics['x_reply_to'] = self.x_reply_to or ''
        self.spam_status = False
        while 'X-Spam-Score' in msg:
            del msg['X-Spam-Score']
        msg['Spam-Stopper-Id'] = self.id
        while 'Spam-Stopper-Policy' in msg:
            del msg['Spam-Stopper-Policy']
        if 'Spam-Stopper-v2' not in msg:
            msg['Spam-Stopper-v2'] = 'Yes'
        self.analytics['x_spam_status'] = False
        self.analytics['x_spf_status'] = msg.get('X-SPF-STATUS')
        self.analytics['x_rdns_status'] = msg.get('X-RDNS-STATUS')
        _smtp_chain, _chain = [], []
        for hop in self.envelope.chain:
            _hop = {'from': hop['from'], 'by': hop['by']}
            if 'tls' in hop:
                _hop['tls_cert_verify'] = hop['tls']['cert_verify']
            _chain.append(_hop)
            _smtp_chain.append('from: {0}; by: {1}'.format(
                hop['from'], hop['by']))
        self.analytics['smtp_chain'] = _smtp_chain
        self.analytics['chain'] = _chain
        self.category = Category.LEGIT
        self.subject = re.sub(
            r'((\n)|(\r)|(\r\n))+(\t| {2,4})*', '',
            get_header(msg['Subject'])).strip()[:SUBJECT_HEADER_LOG_LEN]

    @prometheus('parse_message')
    def parse_message(self):
        with self.time('mail_parse_time'):
            msg = FixedMessage.from_string(self.envelope.content)
            msg.defects.extend(self.envelope.defects)
            defects = [d.__class__.__name__ for d in msg.defects]
            self.analytics['defects'] = defects
            self.email = msg
            self._process_headers()
            message_id = get_header(msg['Message-Id'])
            if message_id:
                message_id = message_id.strip()
            set_user_context(client_mail_id=message_id)
            self.client_message_id = message_id
            self.parse_attachments()
            if defects:
                defected_messages_counter.inc()

    def parse_attachments(self):
        self.attachments = \
            [AttachInfo(self, payload, attach, position) for
             payload, attach, position in self.walk_attachments()]
        first_body_attach_ct = None
        for number, attach in enumerate(self.attachments):
            if number < 2 and \
                    attach.disposition != 'attachment' and \
                    attach.content_type in ['text/plain', 'text/html']:
                if not first_body_attach_ct:
                    attach.is_body = True
                    first_body_attach_ct = attach.content_type
                elif first_body_attach_ct != attach.content_type:
                    attach.is_body = True
                    break
        self.analytics['inbound_attachments_count'] = len(self.attachments)

    def walk_attachments(self, part=None, pos=None):
        if part is None:
            part = self.email
        if part.is_multipart():
            payload = part.get_payload()
            pos = pos or []
            for i, subpart in enumerate(payload):
                sub_pos = pos.copy() + [i]
                if subpart.is_multipart():
                    yield from self.walk_attachments(
                        subpart, sub_pos)
                else:
                    yield payload, subpart, sub_pos

    def set_policy(self, policy: UserPolicy):
        self.policy = policy
        self.account_settings = policy.filtering.get('account') or {}
        self.analytics['policy'] = [
            {
                'ni_name': p['name'],
                'ni_type': p['policy_type'],
                'ni_version': p['last_version'],
                'policy_id': p['policy_id'],
            }
            for p in policy.applied_policies if p
        ]
        self.analytics['tenant_id'] = policy.tenant_id
        policy_logging_settings = self.account_settings.get('logging') or {}
        if not policy_logging_settings.get('exclude_subject', False):
            self.analytics['message_subject'] = self.subject

    def add_dropped(self, attach):
        self._dropped.append(attach)

    async def log_attachments(self):
        for attach in self._dropped:
            await log_attachment(attach)
        self.analytics['outbound_attachments_count'] = len(self.attachments)
        for attach in self.attachments:
            await log_attachment(attach)

    def serialize(self, raw_data=False):
        if raw_data:
            return self.envelope.original_content
        with self.time('serialize'):
            out_data = self.email.as_bytes()
            out_size = len(out_data)
            self.analytics.update({
                'out_size_kb': out_size * 1.0 / 1024,
                'out_size_mb': out_size * 1.0 / (1024 * 1024),
            })
        return out_data

    def serialize_and_sign(self):
        try:
            domain = self.x_from.split('@')[-1].lower() if self.x_from else None
            if not domain:
                return self.serialize()
            dkim_settings = self.policy.get_dkim_settings(domain)
            if not dkim_settings:
                return self.serialize()
            with self.time('serialize_with_dkim'):
                out_data = self.email.sign(dkim_settings)
                out_size = len(out_data)
                self.analytics.update({
                    'out_size_kb': out_size * 1.0 / 1024,
                    'out_size_mb': out_size * 1.0 / (1024 * 1024),
                })
            return out_data
        except BaseException as e:
            sentry_client.captureException()
            logger.error(e)
            return self.serialize()

    def log_delivery(self, name: str, info: dict):
        info['name'] = name
        self.analytics['delivery_relay'].append(info)
