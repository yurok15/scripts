import asyncio
import logging
import pickle

from aes.core.sentry import sentry_client
from aes.core.controller import BaseService
from aes.services.cluster.service import ClusterService
from aes.services.cluster.base import NodeConnectionInfo
from aes.services.cluster.node import ClusterNode
from aes.services.cluster.cluster import CHANNEL_REMOVE, CHANNEL_ADD
from .protocol import AutoDiscoveryProtocol

logger = logging.getLogger(__name__)


class AutoDiscoveryService(BaseService):
    def __init__(self, name, controller, config, loop):
        super(AutoDiscoveryService, self).__init__(
            name, controller, config, loop)
        self.host = config['host']
        self.port = config['port']
        self.period = config['period']
        self.broadcast = config['broadcast']
        self.cluster_service = None
        self.cluster = None
        self.protocol = None
        self.transport = None
        self.ping_task = None
        self.ping_transport = None
        self.ping_port = config.get('ping_port') or self.port

    def protocol_factory(self):
        return AutoDiscoveryProtocol(self.cluster_service.cluster)

    def requires(self, cluster_service: ClusterService):
        self.cluster_service = cluster_service
        self.cluster = cluster = cluster_service.cluster
        cluster.add_connected_callback(self.node_add_callback)

    async def start(self):
        transport, protocol = await self.loop.create_datagram_endpoint(
            self.protocol_factory,
            local_addr=(self.host, self.port),
        )
        self.protocol = protocol
        self.transport = transport
        if self.cluster_service.cluster_name:
            self.ping_task = self.loop.create_task(self.ping_func())

    def close(self):
        if self.transport:
            self.transport.close()
            self.transport = None
        if self.ping_task:
            self.ping_task.cancel()
            self.ping_task = None
        if self.ping_transport:
            self.ping_transport.close()
            self.ping_transport = None

    async def ping_func(self):
        transport, protocol = await self.loop.create_datagram_endpoint(
            self.protocol_factory,
            remote_addr=(self.broadcast, self.ping_port),
            allow_broadcast=True,
        )
        self.ping_transport = transport
        while True:
            try:
                protocol.send_ping(self.cluster_service.port)
            except BaseException as e:
                sentry_client.captureException()
                logger.exception(e)
                await asyncio.sleep(self.period, loop=self.loop)
            else:
                await asyncio.sleep(self.period, loop=self.loop)

    def handle_node_shutdown(self, data: bytes):
        self.cluster.node_shutdown(str(data, encoding='utf-8'))

    def handle_node_add(self, data: bytes):
        info = pickle.loads(data)
        assert isinstance(info, NodeConnectionInfo)
        self.cluster.node_discovered(info)

    def node_add_callback(self, node: ClusterNode):
        node.connect_handlers.append(self.on_node_connect)

    def on_node_connect(self, node, protocol):
        if node.discoverable:
            node.discovery_task = self.loop.create_task(
                self.node_connect_task(node, protocol))

    async def node_connect_task(self, node: ClusterNode, protocol):
        await protocol.subscribe(CHANNEL_ADD, self.handle_node_add)
        await protocol.subscribe(CHANNEL_REMOVE, self.handle_node_shutdown)
        response = await self.cluster.request_node(node.name, 'nodes')
        if 'response' in response:
            infos, shutdowns = response['response']
            for info in infos:
                self.cluster.node_discovered(info)
            for name in shutdowns:
                self.cluster.node_shutdown(name)
