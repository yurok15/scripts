import logging

from prometheus_client.exposition import generate_latest
from prometheus_client.core import REGISTRY

from aes.core.statistics import prometheus
from aes.services.forks.service import ForksService
from aes.services.forks.handler import CommunicationService
from aes.services.http import HttpService, text_response
from aes.core.controller import BaseService

logger = logging.getLogger(__name__)


class PrometheusChannelProtocol:
    def __init__(self, channel):
        self.channel = channel

    def write_data(self, name, dt=None):
        if dt is None:
            data = bytes(name, encoding='utf-8')
        else:
            data = bytes('%s\t%s' % (name, dt), encoding='utf-8')
        self.channel.notify(data)


class PrometheusChannelForkService(BaseService):
    def __init__(self, name, controller, settings, loop):
        super(PrometheusChannelForkService, self).__init__(
            name, controller, settings, loop)
        self.protocol = None

    def requires(self, comm: CommunicationService):
        channel = comm.channels.create_channel('prometheus')
        self.protocol = PrometheusChannelProtocol(channel)

    async def start(self):
        prometheus.connect_to_server(self.protocol)

    def close(self):
        prometheus.connect_to_server(None)


class PrometheusSubscrService(BaseService):
    def __init__(self, name, controller, settings, loop):
        super(PrometheusSubscrService, self).__init__(
            name, controller, settings, loop)
        self._limit = 2 ** 16
        self.transport = None
        self.forks = None  # type: ForksService

    async def start(self):
        if self.forks:
            await self.forks.started
            for node in self.forks.cluster.values():
                protocol = await node.protocol
                await protocol.subscribe('prometheus', self.handler)

    @staticmethod
    def handler(data: bytes):
        data = data.split(b'\t')
        name = data[0]
        name = str(name, encoding='utf-8')
        if len(data) == 2:
            value = data[1]
            value = float(value)
            prometheus.filter_stat_map[name].observe(value)
        else:
            prometheus.filter_stat_map[name].inc()

    def optional(self, http: HttpService, forks: ForksService):
        if http:
            http.add_route('*', '/metrics', self._get_prometheus)
        self.forks = forks
        if forks:
            forks.register_fork_service(
                'prometheus', PrometheusChannelForkService, {})

    @text_response
    async def _get_prometheus(self, request):
        return generate_latest(REGISTRY)
