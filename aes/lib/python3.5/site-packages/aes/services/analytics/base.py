import asyncio
import threading
import logging

import aes.core.analytics as analytics_module
from aes.core.controller import BaseService
from aes.services.forks.service import ForksService


class AnalyticsService(BaseService):
    def __init__(self, name, controller, config, loop):
        super(AnalyticsService, self).__init__(
            name, controller, config, loop)
        self._tasks = {}
        analytics_module.current_backend = self
        self._thread_id = threading.get_ident()
        self.analytics_logger = logging.getLogger('analytics')

    def optional(self, forks: ForksService):
        if forks:
            forks.register_fork_service(self.name, self.__class__, self.config)

    def close(self):
        analytics_module.current_backend = None

    def set_logging_context(self, data):
        task = asyncio.Task.current_task(loop=self.loop)
        if task is None:
            return
        context = self._get_task_context(task)
        context.update(data)

    def get_logging_context(self) -> dict:
        task = asyncio.Task.current_task(loop=self.loop)
        if task is None:
            return {}
        return self._get_task_context(task)

    def _get_task_context(self, task: asyncio.Task):
        thread_id = threading.get_ident()
        if thread_id != self._thread_id:
            return {}
        task_context = self._tasks.get(task, None)
        if task_context is not None:
            return task_context
        task_context = {}
        self._tasks[task] = task_context
        task.add_done_callback(self._task_done_callback)
        return task_context

    def _task_done_callback(self, task: asyncio.Task):
        self._tasks.pop(task, None)

    async def log_message(self, message, data=None):
        self.analytics_logger.warning(message, extra=data)

    async def log_email(self, data):
        await self.log_message('Message_processed', data)
