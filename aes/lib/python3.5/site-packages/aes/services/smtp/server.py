import logging
import ssl

from aes.core.analytics import set_user_context
from aes.core.sentry import sentry_client
from aes.core.exceptions import ImproperlyConfigured, InvalidRecipientPolicy
from aes.core.smtp.protocol import SMTPProtocol, AESEnvelope, MessageUser
from aes.core.controller import BaseService
from aes.services.filtering.processor import MailProcessor


logger = logging.getLogger(__name__)


class InboundSMTPServer(BaseService):
    inbound = True
    config_required = True
    handle_DATA = None

    def __init__(self, name, controller, config, loop):
        super(InboundSMTPServer, self).__init__(name, controller, config, loop)
        self.data_size_limit = config.get('data_size_limit') or 0
        self.helo_string = config.get('helo_string')
        if self.data_size_limit <= 0:
            raise ImproperlyConfigured('Limit cannot be <= 0')
        self.mail_processor = None
        self.sock = config['sock']
        self.server = None
        self.ssl_context = self._ssl_config('ssl')
        self.tls_context = self._ssl_config('starttls')
        if self.ssl_context and self.tls_context:
            raise ValueError('You can`t enable SSL and STARTTLS together')

    def _ssl_config(self, param):
        ssl_settings = self.config.get(param)
        if ssl_settings is not None:
            sc = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)
            sc.load_cert_chain(ssl_settings['cert'], ssl_settings['key'])
            return sc

    def requires(self, processor: MailProcessor):
        self.mail_processor = processor

    async def start(self):
        self.server = await self.loop.create_server(
            self.factory,
            sock=self.sock,
            ssl=self.ssl_context,
        )

    def factory(self):
        return SMTPProtocol(
            self,
            data_size_limit=self.data_size_limit,
            enable_SMTPUTF8=True,
            loop=self.loop,
            hostname=self.helo_string,
            tls_context=self.tls_context,
        )

    def close(self):
        if self.server:
            self.server.close()
            self.server = None

    async def handle_data(self, envelope: AESEnvelope):
        envelope.inbound = self.inbound
        logger.info('Processing message from peer: %s', repr(envelope.peer))
        await self.mail_processor.process_envelope(envelope)
        return '250 2.0.0 Ok: queued as ' + envelope.id

    @staticmethod
    def handle_starttls(session):
        logger.debug(
            'TLS Handshake, peercert: %s, cipher: %s',
            session.ssl['peercert'],
            session.ssl['cipher'])
        return True

    async def handle_rcpt(self, envelope, address, rcpt_options):
        if (not address) or ('@' not in address):
            raise InvalidRecipientPolicy(
                'Syntax: Recipient address invalid')
        policy = None
        if self.inbound:
            set_user_context(user=address)
            service = self.mail_processor.policy_service
            policy = await service.get_full_policy(address, True)
        envelope.rcpt_tos.append(MessageUser(address, policy))
        return '250 OK'

    async def handle_mail(self, envelope, address, mail_options):
        policy = None
        if not self.inbound:
            if (not address) or ('@' not in address):
                raise InvalidRecipientPolicy(
                    'Syntax: Recipient address invalid')
            set_user_context(user=address)
            service = self.mail_processor.policy_service
            policy = await service.get_full_policy(address, False)
        envelope.mail_from = MessageUser(address, policy)
        return '250 OK'

    @staticmethod
    async def handle_exception(e):
        sentry_client.captureException()
        logger.exception(e)
        return '451 Error: (%s) %s' % (e.__class__.__name__, str(e))


class OutboundSMTPServer(InboundSMTPServer):
    inbound = False
