from functools import wraps
import logging
import time
import asyncio
import struct

from aes.core.statistics import prometheus
from aes.core.smtp.protocol import AESEnvelope
from aes.core.controller import BaseService
from aes.core.analytics import set_user_context
from aes.filters.controller import FilterController
from aes.policy_service.policy import MailFilteringPolicyPool, UserPolicy
from aes.delivery.controller import DeliveryController
from aes.services import AnalyticsService
from aes.services.forks.handler import CommunicationService
from aes.message import MessageInfo, TIME_MULTI
from aes.engines.controller import EnginesController

logger = logging.getLogger(__name__)

message_size_counter = prometheus.summary(
    'message_size', 'Analyzed message sizes counter')


def message_processing(func):
    @wraps(func)
    async def wrapper(self, *args, **kwargs):
        self.in_progress += 1
        try:
            return await func(self, *args, **kwargs)
        finally:
            self.in_progress -= 1
    return wrapper


class MailProcessor(BaseService):
    def __init__(self, name, controller, config, loop):
        super(MailProcessor, self).__init__(name, controller, config, loop)
        self.settings = controller.settings
        self.filters = FilterController('', controller, None, loop)
        self.engines = EnginesController('', controller, None, loop)
        self.filters.requires(self.engines)
        self.loop = loop
        self.policy_service = MailFilteringPolicyPool(
            loop=self.loop,
            config=self.settings['POLICY_SERVICE'])
        self.waiter = None
        self.mails_channel = None
        self.delivery = None  # type: DeliveryController
        self.analytics = None  # type: AnalyticsService
        self._in_progress = 0

    def requires(self, delivery: DeliveryController,
                 analytics: AnalyticsService):
        self.delivery = delivery
        self.analytics = analytics

    def optional(self, communicator: CommunicationService):
        if communicator:
            communicator.processor = self
            channels = communicator.channels
            self.mails_channel = channels.create_channel('mail_processor')

    async def start(self):
        await self.engines.start()
        await self.filters.start()

    @property
    def in_progress(self):
        return self._in_progress

    @in_progress.setter
    def in_progress(self, value):
        self._in_progress = value
        if self.mails_channel:
            self.mails_channel.notify(struct.pack('!L', self._in_progress))
        if self.waiter and not self._in_progress:
            self.waiter.set_result(None)

    async def wait(self):
        if self._in_progress:
            self.waiter = asyncio.Future(loop=self.loop)
            await self.waiter

    async def process_envelope(self, envelope: AESEnvelope):
        message_size_counter.observe(len(envelope.original_content))
        await self.engines.process(envelope)
        for rcpt_user in envelope.rcpt_tos:
            if envelope.inbound:
                policy = rcpt_user.policy
                set_user_context(user=rcpt_user.email)
            else:
                policy = envelope.mail_from.policy
            await self.process_mail_message(
                envelope, rcpt_user.email, policy)

    @prometheus('process_mail_message')
    @message_processing
    async def process_mail_message(self, envelope: AESEnvelope,
                                   mail_to: str, policy: UserPolicy):
        """
        Main processor of mail message
        """
        success = False
        total_st = time.time()
        message = MessageInfo(envelope, mail_to)
        try:
            message.parse_message()
            message.set_policy(policy)
            with message.time('filter_controller'):
                await self.filters.apply(message)
            await self.delivery.process(message)
            success = True
        except:
            message.analytics['delivery'] = 'error'
            raise
        finally:
            await message.log_attachments()
            message.timings['total'] = (time.time() - total_st) * TIME_MULTI
            message.analytics['success'] = success
            await self.analytics.log_email(message.analytics)

    def close(self):
        self.policy_service.close()
        self.filters.close()
        self.engines.close()

    def clear_cache(self):
        return self.policy_service.clear()

    def unloop_message(self, message_id):
        self.filters['loop_checker'].skip_loop(message_id)

    async def update_config(self):
        old_controller = self.filters
        old_engines = self.engines
        try:
            self.engines = EnginesController(
                '', self.controller, None, self.loop)
            self.filters = FilterController(
                '', self.controller, None, self.loop)
            self.filters.requires(self.engines)
            await self.engines.start()
            await self.filters.start()
        finally:
            old_controller.close()
            old_engines.close()
