import asyncio
import logging
import pickle

from aes.core.sentry import sentry_client
from aes.core.communication.comm_protocol import CommunicationProtocol


logger = logging.getLogger(__name__)


class NodeConnectionInfo:
    def __init__(self, name: str, cluster_name: str, host: str, port: int):
        self.name = name
        self.cluster_name = cluster_name
        self.host = host
        self.port = port


class HandshakeDiscard(Exception):
    pass


class HandshakeAccept:
    pass


class HandshakeError(Exception):
    pass


class HandshakeCloseUnnecessary(Exception):
    pass


class BaseClusterProtocol(CommunicationProtocol):
    def __init__(self, loop, cluster, handler, node_name=None, timeout=10):
        super(BaseClusterProtocol, self).__init__(
            loop, handler, channels=cluster.channels, timeout=timeout)
        self.cluster = cluster
        self.node_name = node_name
        self.handshake_waiter = asyncio.Future(loop=loop)
        self.greeting = None

    @property
    def remote_host_name(self):
        peername = self.transport.get_extra_info('peername')
        return peername and peername[0]

    async def _read_message_or_exception(self):
        try:
            return await self._read_message()
        except Exception as e:
            return e

    def connection_lost(self, exc):
        logger.debug('Connection lost with node "%s"', self.node_name)
        if self.node_name:
            try:
                self.cluster.node_disconnected(self.node_name, self)
            except BaseException as e:
                logger.exception(e)
                sentry_client.captureException()
        super(BaseClusterProtocol, self).connection_lost(exc)

    async def do_handshake(self, greeting: NodeConnectionInfo):
        raise NotImplementedError

    async def make_request(self, method: str, *args, **kwargs):
        await self.handshake_waiter
        return await super(BaseClusterProtocol, self).make_request(
            method, *args, **kwargs
        )

    def handshake_exception(self, e):
        if self._loop.get_debug():
            logging.exception(e)

    async def _read_handshake_message(self):
        data = await asyncio.wait_for(
            self._read_message_or_exception(),
            self.timeout,
            loop=self._loop,
        )
        if isinstance(data, Exception):
            raise data
        return pickle.loads(data[2])

    def close(self):
        super(BaseClusterProtocol, self).close()
        if not self.handshake_waiter.done():
            self.handshake_waiter.cancel()

    async def execute(self):
        logger.debug('Starting handshake with "%s"', self.node_name)
        handshake_success = False
        try:
            self.write_message('HELO', 0, pickle.dumps(self.cluster.info))
            greeting = await self._read_handshake_message()
            if not isinstance(greeting, NodeConnectionInfo):
                exc = HandshakeDiscard(
                    'Unknown handshake response {cls}'.format(
                        cls=repr(greeting)
                    )
                )
                self.write_message('HELO', 1, pickle.dumps(exc))
                raise exc
            logger.debug('Hello, %s (%s)', greeting.name, greeting.cluster_name)
            self.greeting = greeting
            answer = await self.do_handshake(greeting)
            self.write_message('HELO', 1, pickle.dumps(answer))
            handshake_response = await self._read_handshake_message()
            if not isinstance(answer, HandshakeAccept):
                self.handshake_waiter.set_exception(answer)
            elif not isinstance(handshake_response, HandshakeAccept):
                self.handshake_waiter.set_exception(handshake_response)
            else:
                handshake_success = True
                self.handshake_waiter.set_result(None)
        except asyncio.CancelledError:
            pass
        except BaseException as e:
            self.handshake_waiter.set_exception(e)
            self._exception = e
            self.handshake_exception(e)
        if not handshake_success:
            self.close()
            return
        await super(BaseClusterProtocol, self).execute()

    async def comm_quit(self, number, data):
        await super(BaseClusterProtocol, self).comm_quit(number, data)
        self.cluster.node_shutdown(self.node_name)
