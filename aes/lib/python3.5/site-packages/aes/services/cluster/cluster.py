import asyncio
import logging
import time
import uuid
import pickle

from aes.core.communication.cluster import CommunicationCluster
from aes.core.communication.comm_protocol import ChannelsList
from .base import (
    HandshakeAccept,
    NodeConnectionInfo,
    BaseClusterProtocol,
    HandshakeDiscard,
    HandshakeCloseUnnecessary
)
from .node import ClusterNode, SelfNode
from .shutdown_list import ShutdownList

logger = logging.getLogger(__name__)


class NoClusterRoute(Exception):
    """ Raised in tribe nodes when routing problem happens """


class ClusterRemoteException(Exception):
    """ Raised on unexpected remote errors that can`t be pickled. """

CHANNEL_ADD = 'node_add'
CHANNEL_REMOVE = 'node_remove'


class NodesCluster(CommunicationCluster):
    def __init__(self, service, name, loop, timeout=60):
        super(NodesCluster, self).__init__(loop, timeout=timeout)
        self.shutdown_list = ShutdownList()
        self.node_name = str(uuid.uuid4())
        self.service = service
        self.handler = service.handler
        self.channels = ChannelsList()
        self._ch_remove_node = self.channels.create_channel(CHANNEL_REMOVE)
        self._ch_add_node = self.channels.create_channel(CHANNEL_ADD)
        self.name = name
        self.info = NodeConnectionInfo(
            self.node_name, self.name, service.host, service.port)
        if self.name:
            self[self.node_name] = SelfNode(self.info, self, loop)

    def node_connected(self, info: NodeConnectionInfo,
                       protocol: BaseClusterProtocol):
        """ Connection to node established """
        if self.closed:
            return HandshakeDiscard('Node is closing')
        if info.name == self.node_name:
            logger.error("Someone connects with my node name")
            return HandshakeDiscard('You use my name')
        if self.name and info.cluster_name and self.name != info.cluster_name:
            logger.error("Someone connects from different cluster %s",
                         info.cluster_name)
            return HandshakeDiscard('You are in different cluster')
        node = self.get_node(info, rename=True)
        if node:
            if not node.attach_protocol(protocol):
                logger.warning('Discarding connection to "%s" as unnecessary',
                               repr(node))
                return HandshakeCloseUnnecessary()
        else:
            assert self.name  # Tribe nodes can`t handle incoming connections
            node = ClusterNode(self, info, self.loop)
            node.attach_protocol(protocol)
            self.add_node(node)
            logger.warning("Connected node %s", node)
        return HandshakeAccept()

    def get_node(self, info: NodeConnectionInfo, rename=False):
        for node_name, node in self.items():
            if node_name == info.name:
                return node
            elif node.info.host == info.host and node.info.port == info.port:
                if rename:
                    self.node_rename(node_name, info.name)
                return node

    def add_node(self, node: ClusterNode):
        super(NodesCluster, self).add_node(node)
        self._ch_add_node.notify(pickle.dumps(node.info))

    def node_discovered(self, info: NodeConnectionInfo, permanent=False):
        """ We know about other node in cluster, connect to it """
        if self.closed:
            return
        if info.name == self.node_name:
            return
        if info.name in self.shutdown_list:
            return
        if self.name and info.cluster_name != self.name:
            return
        node = self.get_node(info)
        if node:
            return node
        node = ClusterNode(self, info, self.loop, permanent=permanent)
        logger.warning('Node discovered: %s', node)
        self.add_node(node)
        if self.name or permanent:
            node.do_connect()
        return node

    def node_shutdown(self, node_name: str, timestamp=None):
        if node_name == self.node_name:
            logger.error('Self shutdown received')
            return
        if node_name not in self.shutdown_list:
            self.shutdown_list.add_node(node_name, timestamp)
            self._ch_remove_node.notify(bytes(node_name, encoding='utf-8'))
        if node_name in self:
            node = self.remove_node(node_name)
            logger.warning('Node shutdown received % s', node)
            if node.connected:
                protocol = node.get_protocol()
                protocol.is_closing = True
            node.close()

    def node_disconnected(self, node_name: str,
                          protocol: BaseClusterProtocol):
        """ Connection to node lost """
        if node_name not in self:
            return
        node = self[node_name]

        if node.tribe_node:
            logger.warning('Lost connection with tribe %s', node)
            self.remove_node(node_name)
            return

        if node.connected:
            if node.get_protocol() == protocol:
                logger.error('Lost connection with %s', node)
                node.protocol = None
                if not self.closed:
                    node.do_connect()
            else:
                logger.warning(
                    'Gracefully closed unnecessary connection with %s', node
                )

    def node_closed(self, node_name: str):
        """ We closed connection for some reason """
        if node_name in self:
            node = self[node_name]
            if node.permanent:
                node.protocol = None
                node.do_connect()
            else:
                logger.warning('Removing node')
                del self[node_name]
                node.close()

    def node_rename(self, old_node_name, new_node_name):
        """
        This happen on node static discovery. We don`t know actual node
        names on init, so create host:port names for them, but it can be
        confusing. That`s also can be when we restart one node - its name
        will change
        """
        if old_node_name not in self:
            return False
        node = self[old_node_name]
        logger.warning('Node rename: %s to %s', old_node_name, new_node_name)
        node.name = new_node_name
        del self[old_node_name]
        if new_node_name not in self:
            self[new_node_name] = node
        return True

    async def _close_node(self, node_name):
        if node_name in self:
            await self[node_name].disconnect()
        if node_name in self:
            self.remove_node(node_name)

    async def close_async(self):
        logger.debug("Notify nodes about shutdown")
        while self:
            logger.debug("Wait for nodes to close connections")
            waiters = []
            for node_name in self.keys():
                waiters.append(
                    self.loop.create_task(
                        self._close_node(node_name)
                    )
                )
            await asyncio.wait(waiters, timeout=self.timeout, loop=self.loop)
        logger.debug('Cluster communication closed (%s)', self.node_name)

    def close(self):
        self.closed = True
        self.loop.create_task(self.close_async())

    def _tribe_get_node_for_cluster(self, cluster_name):
        found = None
        for node in self.values():
            if (node.cluster_name != cluster_name) or (not node.permanent):
                continue
            if node.connected:
                return node
            found = node
        return found

    async def request_node(self, name, method, *args, **kwargs):
        node = self[name]
        if self.name or node.permanent:
            return await super(NodesCluster, self).request_node(
                name, method, *args, **kwargs
            )
        # for tribe nodes to request node we don`t directly connected we must
        # use other node in cluster that we connected.
        node = self._tribe_get_node_for_cluster(node.cluster_name)
        if node is None:
            raise NoClusterRoute('Route to node %s not found', name)
        response = await super(NodesCluster, self).request_node(
            node.name, 'tribe_request_node', name, method, *args, **kwargs
        )

        if 'response' not in response:
            raise ClusterRemoteException(response['error'])
        return response['response']

    async def make_request(self, method, *args, **kwargs):
        if self.name:
            response = await super(NodesCluster, self).make_request(
                method, *args, **kwargs
            )
            responses = response.get('responses') or {}
            for node_response in responses.values():
                node_response['cluster_name'] = self.name
            return response
        # for tribe nodes we must make request through all known clusters
        clusters = []
        for node in self.values():
            if node.cluster_name and node.cluster_name not in clusters:
                clusters.append(node.cluster_name)
        if not clusters:
            raise NoClusterRoute('Not connected to cluster')
        clusters = {
            name: self._tribe_get_node_for_cluster(name) for name in clusters
        }
        tasks = {}
        start = time.time()
        for cluster_name, node in clusters.items():
            tasks[cluster_name] = self.loop.create_task(
                self.request_node(
                    node.name, 'tribe_make_request', method, *args, **kwargs)
            )
        success = True
        response = {'responses': {}}
        for cluster_name, task in tasks.items():
            result = await task
            if 'response' not in result:
                raise ClusterRemoteException(result['error'])
            responses = result['response']['responses']
            for node_name, node_response in responses.items():
                node_response['cluster_name'] = cluster_name
                response['responses'][node_name] = node_response
                if success and not node_response['success']:
                    success = False
        response['success'] = success
        response['time'] = time.time() - start
        return response
