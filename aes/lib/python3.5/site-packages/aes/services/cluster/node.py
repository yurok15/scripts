import asyncio
from typing import Optional
import logging
import time
import uuid

from aes.core.statistics import prometheus
from aes.core.communication.cluster import CommunicationClusterNode
from .base import (
    BaseClusterProtocol,
    NodeConnectionInfo,
    HandshakeDiscard,
    HandshakeCloseUnnecessary,
)
from .client_protocol import ClusterClientProtocol

logger = logging.getLogger(__name__)

node_connection_errors = prometheus.counter('node_connection_errors')
node_ping_errors = prometheus.counter('node_ping_errors')


class ClusterPingError(BaseException):
    pass


class ClusterNode(CommunicationClusterNode):
    OK_STATUS = 'Ok'
    INIT_STATUS = 'Initializing'

    def __init__(self, cluster, info: NodeConnectionInfo, loop,
                 permanent=False):
        self.info = info
        self.cluster_name = info.cluster_name
        self.service = cluster.service
        self.cluster = cluster
        self.loop = loop
        self.permanent = permanent
        self.connection_errors = 0
        self._status = self.INIT_STATUS
        self.connect_task = None
        super(ClusterNode, self).__init__(info.name, None)

    @property
    def discard_own_connection(self):
        node_uuid = uuid.UUID(self.name)
        my_uuid = uuid.UUID(self.cluster.node_name)
        return my_uuid < node_uuid

    @property
    def discoverable(self) -> bool:
        return bool(self.cluster_name)

    @property
    def requestable(self) -> bool:
        return bool(self.cluster_name)

    @property
    def tribe_node(self):
        return self.cluster_name is None

    @property
    def status(self):
        if self.connected:
            protocol = self._protocol
            updated = time.monotonic() - protocol.last_updated
            if updated > protocol.timeout * 2:
                return "No ping in %d" % updated
        return self._status

    def do_connect(self):
        if self._protocol:
            return
        logger.warning('Starting connect %s:%s (%s)',
                       self.info.host, self.info.port, self.name)
        self._protocol = self.loop.create_future()
        self.connect_task = self.loop.create_task(self.connect_coroutine())

    def on_connect(self):
        super(ClusterNode, self).on_connect()
        self._status = self.OK_STATUS
        logger.warning('Connection to node %s established', repr(self))

    async def connect_coroutine(self) -> Optional[BaseClusterProtocol]:
        """ Task for other node connection """
        success = False
        while not success:
            protocol = None
            try:
                _, protocol = await asyncio.wait_for(
                    self.loop.create_connection(
                        ClusterClientProtocol.factory(self),
                        host=self.info.host,
                        port=self.info.port
                    ),
                    self.cluster.timeout,
                    loop=self.loop
                )
                await protocol.handshake_waiter
                self.attach_protocol(protocol)
                success = True
            except HandshakeCloseUnnecessary:
                logger.info('Connection to %s discarded as unnecessary',
                            repr(self))
                return
            except HandshakeDiscard as e:
                logger.warning('Handshake discarded: %s', repr(e))
                if isinstance(self._protocol, asyncio.Future):
                    self._protocol.set_exception(e)
                    self._protocol = None
                self.cluster.node_closed(self.name)
                return
            except asyncio.CancelledError:
                return
            except BaseException as e:
                node_connection_errors.inc()
                self.connection_errors += 1
                self._status = '(%s) %s' % (e.__class__.__name__, str(e))
                await asyncio.sleep(
                    self.service.reconnect_period, loop=self.loop
                )
            finally:
                if not success and protocol:
                    protocol.close()
        self.connect_task = None

    def attach_protocol(self, protocol):
        if not self.connected:
            self.protocol = protocol
        else:
            assert self._protocol != protocol
            if isinstance(protocol, ClusterClientProtocol):
                # if that our initiated connect:
                # if we are not in priority, than just fail handshake
                # if we are in priority, than drop existing connection and
                # use this one
                discard = self.discard_own_connection
            else:
                # if it is client connected:
                # if he has priority, then drop existing connection and
                # use this one.
                # if we have priority, discard it.
                discard = not self.discard_own_connection
            if discard:
                logger.warning("Discard existing connection to %s", repr(self))
                return False
            else:
                logger.warning("Use new connection to %s", repr(self))
                self.protocol = protocol
        self._status = self.OK_STATUS
        return True

    def close(self):
        if self.connected:
            protocol = self.get_protocol()
            protocol.close()
            self._protocol = None
        super(ClusterNode, self).close()
        if self.connect_task:
            self.connect_task.cancel()
            self.connect_task = None

    def __str__(self):
        return "{host}:{port} ({name})".format(
            host=self.info.host, port=self.info.port, name=self.name
        )

    def __repr__(self):
        return "Node {host}:{port} ({name})".format(
            host=self.info.host, port=self.info.port, name=self.name
        )

    async def disconnect(self):
        logger.debug('Disconnect from %s', repr(self))
        if self.connected:
            protocol = self.get_protocol()
            protocol.gracefully_close()
        self.close()


class SelfNode(ClusterNode):
    def __init__(self, info, cluster, loop):
        super(SelfNode, self).__init__(cluster, info, loop)
        self.handler = cluster.handler

    @property
    def discoverable(self):
        return False

    @property
    def status(self):
        return self.OK_STATUS

    def do_connect(self):
        pass

    @property
    def connected(self):
        return True

    async def make_request(self, method, *args, **kwargs) -> dict:
        func = getattr(self.handler, method)
        return await func(*args, **kwargs)

    async def disconnect(self):
        pass
