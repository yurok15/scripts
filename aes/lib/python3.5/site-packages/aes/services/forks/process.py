import asyncio
from logging.config import dictConfig
import logging
import multiprocessing
import time

# pylint: disable=no-name-in-module
from setproctitle import setproctitle

from aes.core.loop import get_prepared_loop, finalize_loop
from aes.core.sentry import sentry_client
from aes.core.controller import ServicesController

logger = logging.getLogger(__name__)


class ForkController(ServicesController):
    def __init__(self, process):
        self.fork_name = process.num
        self.comm_sock = process.comm_sock
        super(ForkController, self).__init__(
            process.settings, process.services, process.loop)


class AESProcess(multiprocessing.Process):

    def __init__(self, num, comm_sock, services, settings):
        super(AESProcess, self).__init__(name='Worker %s' % num)
        self.num = num
        self.services = services
        self.settings = settings
        self.comm_sock = comm_sock
        self.loop = None

    def prepare_loop(self, loop=None):
        # analytics mail context works only with current loop
        # we need to delete current loop to be sure no side effects of forking
        loop = loop or asyncio.new_event_loop()
        self.loop = get_prepared_loop(self.settings, loop=loop)
        asyncio.set_event_loop(self.loop)

    def prepare_settings(self):
        dictConfig(self.settings['LOGGING'])

    def close(self):
        finalize_loop(self.loop)

    def run(self):
        setproctitle('AESCoreWorker%s' % self.num)
        try:
            self.prepare_settings()
            self.prepare_loop(self.loop)
            try:
                with ForkController(self) as c:
                    self.loop.run_until_complete(c.start())
                    self.loop.run_forever()
            finally:
                self.close()
        except KeyboardInterrupt:
            pass
        except Exception as e:
            sentry_client.captureException()
            logger.exception(e)
            # required to sentry to correctly send info in thread
            time.sleep(3)
            raise
        finally:
            logger.warning('Stopped worker %s', repr(self))
