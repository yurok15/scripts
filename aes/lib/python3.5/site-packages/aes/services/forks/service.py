import logging
import socket
import multiprocessing

from aes.core.communication.cluster import (
    CommunicationCluster,
    CommunicationClusterNode,
)
from aes.core.communication.comm_protocol import CommunicationProtocol
from aes.services.forks.process import AESProcess
from aes.services.http import HttpService, json_response
from aes.core.controller import BaseService
from .handler import CommunicationService

logger = logging.getLogger(__name__)


class ForksService(BaseService):
    config_required = True

    def __init__(self, name, controller, config, loop):
        super(ForksService, self).__init__(name, controller, config, loop)
        self.processes = []
        self.processes_num = config['count'] or 1
        self.cluster = CommunicationCluster(loop)
        self.services = {
            'communicator': {
                'class': CommunicationService
            }
        }

    async def start(self):
        self.processes = []
        multiprocessing.set_start_method('spawn')
        for i in range(self.processes_num):
            client, server = socket.socketpair()
            process = AESProcess(
                i, client, self.services, self.controller.settings)
            self.processes.append(process)
            protocol = await CommunicationProtocol.connect_socket(
                self.loop, server, None
            )
            self.cluster.add_node(CommunicationClusterNode(i, protocol))

        for process in self.processes:
            logger.warning('Spawn process %s', repr(process))
            process.start()

    def optional(self, http: HttpService):
        if http:
            http.add_route('*', '/ping', self.ping)
            http.add_route('*', '/status_report', self.status_report)

    @json_response
    async def ping(self, request):
        return await self.cluster.make_request('ping')

    @json_response
    async def status_report(self, request):
        return await self.cluster.make_request('status_report')

    def register_fork_service(self, name, cls, config: dict):
        assert not self.started.done()
        assert name not in self.services
        config = config or {}
        config['class'] = cls
        self.services[name] = config

    def close(self):
        logger.warning('Waiting workers')
        for process in self.processes:
            process.join()
        self.cluster.close()
