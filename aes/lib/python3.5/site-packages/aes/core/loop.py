import asyncio
import sys
import logging
import logging.config

from aes.core.sentry import sentry_client
from aes.conf import Settings


class AESTask(asyncio.Task):
    def set_exception(self, exception):
        super(AESTask, self).set_exception(exception)
        sentry_client.captureException()
        logging.exception(exception)


def task_factory(loop, coro):
    return AESTask(coro, loop=loop)


def stop_loop(loop):
    def stopper():
        logging.warning('Recieved STOP signal, stopping')
        loop.stop()
    return stopper


def loop_exception_handler(loop, context):
    sentry_client.captureException(extra=context)
    logging.exception(str(context))


def get_settings():
    settings = Settings()
    logging.config.dictConfig(settings['LOGGING'])
    return settings


def get_prepared_loop(settings, loop=None):
    loop = loop or asyncio.get_event_loop()
    if settings['DEBUG']:
        loop.set_task_factory(task_factory)
        loop.set_debug(True)
    loop.set_exception_handler(loop_exception_handler)
    if sys.platform != 'win32':
        import signal
        loop.add_signal_handler(signal.SIGTERM, stop_loop(loop))
    return loop


def finalize_loop(loop):
    loop.stop()
    # sometimes its not enough and we need one more iteration for
    # callbacks of callbacks
    f = getattr(loop, '_run_once')
    while True:
        ready = getattr(loop, '_ready')
        if ready:
            # iterate loop while there are ready callbacks
            f()
            continue
        else:
            break
    # here we have no ready callbacks, do one more iteration to be sure,
    # that there is no data in loop selector
    # add empty task to be shure that we wouldn`t freeze on selector
    loop.create_task(asyncio.sleep(0, loop=loop))
    while True:
        ready = getattr(loop, '_ready')
        f()
        if not ready:
            break
