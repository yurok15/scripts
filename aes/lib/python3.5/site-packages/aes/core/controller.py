import logging
import inspect
from importlib import import_module
from asyncio.selector_events import BaseSelectorEventLoop
from collections import OrderedDict

from aes.core.exceptions import ImproperlyConfigured

logger = logging.getLogger(__name__)


class ConfigRequired(Exception):
    pass


class BaseService:
    config_required = False

    def __init__(self, name, controller, config, loop: BaseSelectorEventLoop):
        if self.config_required and config is None:
            raise ConfigRequired()
        self.config = config
        self.loop = loop
        self.controller = controller
        self.started = loop.create_future()
        self.name = name

    async def start(self):
        pass

    def close(self):
        pass

    def requires(self, *args):
        """
        This is magic function. You may provide any args annotated with
        required external services. They will be started automatically as
        your requirements and after that this function will be called with
        their instances as arguments.
        """
        pass

    def optional(self, *args):
        """
        This is magic function. You may provide any args annotated with
        required external services. After start function will be called with
        available services. If service is unavailable, value will be None.
        """
        pass

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.close()


class BaseController(BaseService):
    log_level = logging.WARNING
    base_class = BaseService

    def __init__(self, name, owner, config, loop: BaseSelectorEventLoop):
        super(BaseController, self).__init__(name, owner, config, loop)
        self.services = OrderedDict()
        for s_name, service_config in config.items():
            service_config = service_config.copy()
            cls_path = service_config.pop('class', None)
            if not cls_path:
                raise ImproperlyConfigured('No class configured for %s', s_name)
            if callable(cls_path):
                service_cls = cls_path
            else:
                mod_path, cls_name = cls_path.rsplit('.', 1)
                service_cls = getattr(import_module(mod_path), cls_name)
            self.create_service(s_name, service_cls, service_config)
        logger.log(self.log_level, 'Process requirements')
        for service in list(self.services.values()):
            self.process_requirements(service)
        logger.log(self.log_level, 'Process optionals')
        for service in list(self.services.values()):
            self.process_optionals(service)

    async def start_service(self, service: BaseService):
        await service.start()
        logger.log(self.log_level, '%s started', service.__class__.__name__)
        service.started.set_result(True)

    async def start(self):
        assert not self.started.done()
        logger.log(self.log_level, 'Async start')
        tasks = []
        for service in self.services.values():
            tasks.append(
                self.loop.create_task(
                    self.start_service(service)
                )
            )
        for task in tasks:
            await task
        return self

    def _service_factory(self, name, service_cls, config):
        return service_cls(name, self, config, self.loop)

    def create_service(self, name: str, service_cls: type, config):
        assert name not in self.services
        if not issubclass(service_cls, self.base_class):
            raise ImproperlyConfigured('%s is not right class for controller',
                                       name)
        try:
            service = self._service_factory(name, service_cls, config)
        except:
            logger.error('Create service failed: %s', name)
            raise
        logger.log(self.log_level, '[ OK ] %s: %s', name, service_cls.__name__)
        self.services[name] = service
        return service

    def find_cls(self, cls):
        for service in self.services.values():
            if isinstance(service, cls):
                return service

    def process_requirements(self, service: BaseService, processed=None):
        sig = inspect.signature(service.requires)
        args = []
        processed = processed or [service.__class__]
        for param in sig.parameters.values():
            if param.kind == param.VAR_POSITIONAL:
                # that is *args param
                continue
            if not issubclass(param.annotation, BaseService):
                raise ImproperlyConfigured("Service cant require %s" %
                                           param.annotation.__class__)
            req_cls = param.annotation
            instance = self.find_cls(req_cls)
            if not instance:
                try:
                    instance = self.create_service(str(req_cls), req_cls, None)
                except ConfigRequired:
                    raise ImproperlyConfigured(
                        '%s cant be started as %s is not configured',
                        service, req_cls)
                processed.append(req_cls)
                self.process_requirements(instance, processed)
            args.append(instance)
        service.requires(*args)

    def process_optionals(self, service: BaseService):
        sig = inspect.signature(service.optional)
        args = []
        for param in sig.parameters.values():
            if param.kind == param.VAR_POSITIONAL:
                # that is *args param
                continue
            if not issubclass(param.annotation, BaseService):
                raise ImproperlyConfigured("Service cant require %s" %
                                           param.annotation.__class__)
            req_cls = param.annotation
            args.append(self.find_cls(req_cls))
        service.optional(*args)

    def close(self):
        logger.log(self.log_level, 'Stop services')
        while self.services:
            name, service = self.services.popitem(last=False)
            logger.log(self.log_level, 'Stop %s', name)
            try:
                service.close()
            except BaseException:
                logger.exception("Service failed to stop")
        logger.log(self.log_level, 'All services stopped')

    def __getitem__(self, item):
        if isinstance(item, type):
            return self.find_cls(item)
        return self.services[item]


class ServicesController(BaseController):
    def __init__(self, settings, config, loop: BaseSelectorEventLoop):
        self.settings = settings
        super(ServicesController, self).__init__(None, None, config, loop)

    async def start(self):
        await super(ServicesController, self).start()
        self.started.set_result(True)
        return self
