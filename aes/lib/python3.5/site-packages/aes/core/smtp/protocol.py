import logging
import socket
import ssl
import os
import uuid
import asyncio
from asyncio import sslproto

from aiosmtpd.smtp import (
    DATA_SIZE_DEFAULT,
    SMTP,
    log,
    MISSING,
    Envelope,
    Session,
)
from aes import __version__
from aes.core.exceptions import ImproperlyConfigured
from aes.core.analytics import set_user_context

logger = logging.getLogger(__name__)


class MessageUser:
    def __init__(self, mail_address, policy=None):
        self.email = mail_address
        self.policy = policy


class AESEnvelope(Envelope):
    def __init__(self, *, inbound=True, session=None,
                 peer=None, mail_from=None, data=None):
        super(AESEnvelope, self).__init__()
        if mail_from:
            self.mail_from = MessageUser(mail_from)
        self.session = session
        self.peer = session.peer if session else peer
        self.id = str(uuid.uuid4())
        self.pid = os.getpid()
        self.inbound = inbound
        self.original_content = data
        self._content = None
        self.engines = None
        self.hash = None
        self.email = None
        self.source_ip = None
        self.gate_record = None
        self.chain = []
        self.defects = []
        set_user_context(
            message_id=self.id,
            pid=self.pid,
        )

    @property
    def content(self):
        if self._content is None:
            self._content = self.original_content.decode(
                'ASCII', errors='surrogateescape')
        return self._content

    @content.setter
    def content(self, value):
        self._content = value


class SMTPProtocol(SMTP):
    num_bytes = 0
    received_data = None
    smtp_state = None
    transport = None

    def __init__(self, handler,
                 *,
                 data_size_limit=DATA_SIZE_DEFAULT,
                 enable_SMTPUTF8=False,
                 decode_data=False,
                 hostname=None,
                 tls_context=None,
                 require_starttls=False,
                 loop=None):
        self.__ident__ = __version__
        if data_size_limit <= 0:
            raise ImproperlyConfigured('Limit cannot be <= 0')
        self.loop = loop if loop else asyncio.get_event_loop()
        asyncio.StreamReaderProtocol.__init__(
            self,
            asyncio.StreamReader(loop=self.loop, limit=data_size_limit),
            client_connected_cb=self._client_connected_cb,
            loop=self.loop)
        self.event_handler = handler
        self.data_size_limit = data_size_limit
        self.enable_SMTPUTF8 = enable_SMTPUTF8
        self._decode_data = decode_data
        self.command_size_limits.clear()
        if hostname:
            self.hostname = hostname
        else:
            self.hostname = socket.getfqdn()
        self.tls_context = tls_context
        if tls_context:
            # Through rfc3207 part 4.1 certificate checking is part of SMTP
            # protocol, not SSL layer.
            self.tls_context.check_hostname = False
            self.tls_context.verify_mode = ssl.CERT_NONE
        self.require_starttls = tls_context and require_starttls
        self._tls_handshake_okay = True
        self._tls_protocol = None
        self.session = None
        self.envelope = None
        self.transport = None
        self._handler_coroutine = None

    def _create_session(self):
        session = Session(self.loop)
        session.protocol = self
        return session

    def _create_envelope(self):
        return AESEnvelope(session=self.session)

    @asyncio.coroutine
    def _call_handler_hook(self, command, *args):
        hook = getattr(self.event_handler, 'handle_' + command.lower(), None)
        if hook is None:
            return MISSING
        status = yield from hook(self.envelope, *args)
        return status

    def connection_made(self, transport):
        # Reset state due to rfc3207 part 4.2.
        self.session = self._create_session()
        self.session.peer = transport.get_extra_info('peername')
        is_instance = isinstance(transport, sslproto._SSLProtocolTransport)
        if self.transport is not None and is_instance:   # pragma: nossl
            # It is STARTTLS connection over normal connection.
            self._reader._transport = transport
            self._writer._transport = transport
            self.transport = transport
            # Do SSL certificate checking as rfc3207 part 4.1 says.
            # Why _extra is protected attribute?
            self.session.ssl = self._tls_protocol._extra
            handler = getattr(self.event_handler, 'handle_starttls', None)
            if handler is None:
                self._tls_handshake_okay = True
            else:
                self._tls_handshake_okay = handler(self.session)
        else:
            asyncio.StreamReaderProtocol.connection_made(self, transport)
            self.transport = transport
            log.info('Peer: %s', repr(self.session.peer))
            # Process the client's requests.
            self._handler_coroutine = self.loop.create_task(
                self._handle_client())

    async def _handle_client(self):
        self._set_rset_state()
        await super(SMTPProtocol, self)._handle_client()
