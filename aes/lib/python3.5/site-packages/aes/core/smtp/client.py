import ssl as ssllib
import socket
import logging
import json
import asyncio
from asyncio import sslproto
from base64 import b64encode

from aiosmtplib.smtp import (
    SMTP,
    SMTPRecipientsRefused,
    SMTPDataError,
    MAX_LINE_LENGTH,
    SMTPConnectError,
    status,
    SMTP_PORT,
    SMTPServerDisconnected,
    SMTPSenderRefused,
    quote_address,
    SMTPResponseException,
    SMTPRecipientRefused,
)
from aiosmtplib.streams import SMTPStreamReader, SMTPStreamWriter
from aiosmtplib.textutils import LINE_ENDINGS_REGEX, PERIOD_REGEX

POSTFIX_STR = 'queued as '

logger = logging.getLogger(__name__)


def fixed_encode_message_string(message_str):
    if isinstance(message_str, str):
        message_bytes = message_str.encode('utf-8')
    else:
        assert isinstance(message_str, bytes)
        message_bytes = message_str
    message_bytes = LINE_ENDINGS_REGEX.sub(b"\r\n", message_bytes)
    message_bytes = PERIOD_REGEX.sub(b'..', message_bytes)
    if not message_bytes.endswith(b"\r\n"):
        message_bytes += b"\r\n"
    message_bytes += b".\r\n"
    return message_bytes


class FixedSMTPStreamWriter(SMTPStreamWriter):
    async def send_command(self, *args, encoding='ascii'):
        """
        Format a command and send it to the server.
        """
        b_args = []
        for arg in args:
            if isinstance(arg, str):
                arg = bytes(arg, encoding=encoding, errors="surrogateescape")
            else:
                assert isinstance(arg, bytes)
            b_args.append(arg)
        command = b' '.join(b_args) + b'\r\n'
        self.write(command)
        await self.drain()


class FixedSMTPStreamReader(SMTPStreamReader):
    async def read_response(self):
        """
        Get a status reponse from the server.
        Returns a tuple consisting of:
          - server response code (e.g. 250, or such, if all goes well)
          - server response string corresponding to response code (multiline
            responses are converted to a single, multiline string).
        Raises SMTPResponseException for codes > 500.
        """
        code = None
        response_lines = []

        while True:

            try:
                line = await self.readline()
            except ValueError:
                raise SMTPResponseException(500, "Line too long.")
            except ConnectionError as exc:
                raise SMTPServerDisconnected(exc)

            if not line:
                raise SMTPServerDisconnected

            try:
                code = int(line[:3])
            except ValueError:
                pass

            message = line[4:].strip(b' \t\r\n').decode('ascii')
            response_lines.append(message)
            if line[3:4] != b"-":
                break

        full_message = "\n".join(response_lines)

        if code is None:
            raise SMTPResponseException(
                -1, 'Malformed SMTP response: {}'.format(full_message))

        if status.is_permanent_error_code(code):
            raise SMTPResponseException(code, full_message)

        return code, full_message


class SMTPProtocol(asyncio.StreamReaderProtocol):
    _transport = None

    def connection_made(self, transport):
        if (self._transport is not None
                and isinstance(transport, sslproto._SSLProtocolTransport)):
            # It is STARTTLS connection over normal connection
            self._stream_reader._transport = transport
            self._over_ssl = True
        else:
            super().connection_made(transport)
        self._transport = transport


class PatchedSMTP(SMTP):
    def __init__(self, hostname='localhost', port=SMTP_PORT,
                 source_address=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
                 loop=None, default_8bit_encoding='latin_1',
                 enable_smtputf8=True, tls_context=None):
        super(PatchedSMTP, self).__init__(hostname=hostname, port=port,
                                          source_address=source_address,
                                          timeout=timeout, loop=loop)
        self.default_8bit_encoding = default_8bit_encoding
        self.enable_smtp_utf8 = enable_smtputf8
        self._tls_protocol = None
        self._tls_context = tls_context
        self.tls_extra = None

    @property
    def supports_utf8(self):
        return self.enable_smtp_utf8 and self.supports_extension('SMTPUTF8')

    @property
    def supports_8bit_encoding(self):
        return (self.default_8bit_encoding
                and self.supports_extension('8BITMIME'))

    @property
    def supports_aesreport(self):
        return self.supports_extension('AESREPORT')

    def get_encoding(self):
        if self.supports_utf8:
            return 'utf-8'
        elif self.supports_8bit_encoding:
            return self.default_8bit_encoding
        return 'ascii'

    async def execute_command(self, *args, encoding=None):
        """
        Send the commands given and return the reply message.

        Returns (code, message) tuple.
        """
        if not self.is_connected:
            message = 'Not connected to SMTP server {}:{}'.format(
                self.hostname, self.port)
            raise SMTPServerDisconnected(message)
        encoding = encoding or self.get_encoding()
        await self.writer.send_command(*args, encoding=encoding)
        code, message = await self.reader.read_response()

        # If the server is unavailable, shut it down
        if code == status.SMTP_421_DOMAIN_UNAVAILABLE:
            await self.close()

        return code, message

    async def send_aesreport(self, analytics: dict):
        """
        Send AES report as JSON serialized and BASE64 encoded data if
        quarantine server supports SMTP same extension.

        Returns (code, message) tuple.
        """
        code, message = await self.execute_command('AESREPORT')

        if code != status.SMTP_354_START_INPUT:
            raise SMTPResponseException(code, message)

        try:
            data = json.dumps(analytics, ensure_ascii=True)
        except TypeError as e:
            logger.error('Message analytics serialization error: ' + str(e))
            return -1, ''
        data = b64encode(bytearray(data.encode('ascii')))

        while data and self.is_connected:
            self.writer.write(data[:MAX_LINE_LENGTH - 2] + b'\r\n')
            data = data[MAX_LINE_LENGTH - 2:]
        self.writer.write(b'\r\n')
        await self.writer.drain()

        code, message = await self.reader.read_response()
        if code != status.SMTP_220_READY:
            raise SMTPResponseException(code, message)

        return code, message

    async def mail(self, sender, options=None):
        """
        Sends the SMTP 'mail' command (begins mail transfer session)
        Returns a (code, message) tuple with the server response.

        Raises SMTPSenderRefused if the response is not 250.
        """
        if options is None:
            options = []
        if isinstance(sender, str):
            from_string = "FROM:{}".format(quote_address(sender))
        else:
            assert isinstance(sender, bytes)
            from_string = b'FROM:' + sender

        code, message = await self.execute_command("mail", from_string,
                                                   *options)

        if code != status.SMTP_250_COMPLETED:
            raise SMTPSenderRefused(code, message, sender)

        return code, message

    async def rcpt(self, recipient, options=None):
        """
        Sends the SMTP 'rcpt' command (specifies a recipient for the message)
        Returns a (code, message) tuple with the server response.
        """
        if options is None:
            options = []
        if isinstance(recipient, str):
            to = "TO:{}".format(quote_address(recipient))
        else:
            assert isinstance(recipient, bytes)
            to = b'TO:' + recipient

        # Turn a generic STMPResponseException into SMTPRecipientRefused
        try:
            code, message = await self.execute_command("rcpt", to, *options)
        except SMTPResponseException as exc:
            code, message = exc.code, exc.message

        success_codes = (
            status.SMTP_250_COMPLETED,
            status.SMTP_251_WILL_FORWARD,
        )
        if code not in success_codes:
            raise SMTPRecipientRefused(code, message, recipient)

        return code, message

    async def data(self, message):
        """
        Sends the SMTP 'data' command (sends message data to server)

        Raises SMTPDataError if there is an unexpected reply to the
        DATA command.

        Returns a (code, message) response tuple (the last one, after all
        data is sent.)
        """
        code, response = await self.execute_command("data")
        if code != status.SMTP_354_START_INPUT:
            raise SMTPDataError(code, response)

        encoded_message = fixed_encode_message_string(message)
        self.writer.write(encoded_message)

        code, response = await self.reader.read_response()
        if code != status.SMTP_250_COMPLETED:
            raise SMTPDataError(code, response)

        return code, response

    async def connect(self, ssl=None):
        """
        Open asyncio streams to the server and check response status.
        """
        self.reader = FixedSMTPStreamReader(limit=MAX_LINE_LENGTH,
                                            loop=self.loop)
        self.protocol = SMTPProtocol(self.reader, loop=self.loop)

        try:
            self.transport, _ = await self.loop.create_connection(
                lambda: self.protocol, self.hostname, self.port, ssl=ssl)
        except (ConnectionRefusedError, OSError):
            message = "Error connecting to {host} on port {port}".format(
                host=self.hostname, port=self.port)
            raise SMTPConnectError(message)
        else:
            self.writer = FixedSMTPStreamWriter(self.transport, self.protocol,
                                                self.reader, self.loop)

        code, message = await self.reader.read_response()
        if not status.is_success_code(code):
            raise SMTPConnectError(message)

    async def sendmail(self, sender, recipients, message, mail_options=None,
                       rcpt_options=None, analytics=None):
        if isinstance(recipients, (str, bytes)):
            recipients = [recipients]
        if mail_options is None:
            mail_options = []
        if rcpt_options is None:
            rcpt_options = []

        await self.ehlo_or_helo_if_needed()

        if self.supports_esmtp and self.supports_extension('size'):
            size_option = "size={}".format(len(message))
            mail_options.append(size_option)

        if (self._tls_context
                and self.supports_extension('starttls')
                and (self._tls_protocol is None)):
            await self.starttls(self._tls_context)
            await self.ehlo_or_helo_if_needed()

        if self.supports_aesreport and analytics:
            await self.send_aesreport(analytics)

        await self.mail(sender, options=mail_options)

        recipient_errors = {}
        for address in recipients:
            try:
                await self.rcpt(address, options=rcpt_options)
            except SMTPRecipientRefused as exc:
                recipient_errors[address] = (exc.code, exc.message)

        if len(recipient_errors) == len(recipients):
            raise SMTPRecipientsRefused(recipient_errors)

        code, response = await self.data(message)

        if code not in (status.SMTP_250_COMPLETED,
                        status.SMTP_251_WILL_FORWARD):
            raise SMTPResponseException(code, message)
        return recipient_errors, response

    def _set_rset_state(self):
        self.last_helo_response = (None, None)
        self.last_ehlo_response = (None, None)
        self.esmtp_extensions = {}

    async def starttls(self, tls_context=None):
        purpose = ssllib.Purpose.CLIENT_AUTH
        tls_context = (tls_context
                       or self._tls_context
                       or ssllib.create_default_context(purpose))
        # Turn off checking on handshake level. Due to rfc3207 part 4.1 we
        # must send correct QUIT command if security isn`t enought, not drop
        # connection on handshake.
        tls_context.check_hostname = False
        tls_context.verify_mode = ssllib.CERT_NONE
        try:
            code, message = await self.execute_command("STARTTLS")
        except SMTPResponseException as exc:
            code, message = exc.code, exc.message

        success_codes = (
            status.SMTP_250_COMPLETED,
            status.SMTP_220_READY,
        )
        if code not in success_codes:
            raise SMTPResponseException(code, message)
        waiter = self.loop.create_future()
        self._tls_protocol = sslproto.SSLProtocol(
            self.loop,
            self.protocol,
            tls_context,
            waiter,
            server_side=False
        )
        # reconfigure transport layer
        socket_transport = self.transport
        socket_transport._protocol = self._tls_protocol
        # reconfigure protocol layer. Cant understand why app transport is
        # protected property, if it MUST be used externally
        self.transport = self._tls_protocol._app_transport
        # start handshake
        self._tls_protocol.connection_made(socket_transport)
        await waiter
        self.writer._transport = self.transport
        # Reset state due to rfc3207 part 4.2
        self._set_rset_state()
        # return SSL layer information to provide upper level deside,
        # what to do with it.
        # Why _extra is protected attribute?
        self.tls_extra = self._tls_protocol._extra
        return self.tls_extra
