import asyncio
import pickle
import inspect

from .protocol import BaseCommunicationProtocol, ProtocolRecoverableException


class SubscriptionError(Exception):
    pass


class CommunicationRequest:
    def __init__(self, method, args, kwargs):
        self.method = method
        self.args = args
        self.kwargs = kwargs


class Channel:
    def __init__(self):
        self.subscriptions = {}

    def subscribe(self, protocol, number):
        if protocol in self.subscriptions:
            raise SubscriptionError('Already subscribed')
        self.subscriptions[protocol] = number

    def notify(self, data: bytes):
        for protocol, number in self.subscriptions.items():
            protocol.notify(number, data)

    def unsubscribe(self, protocol):
        del self.subscriptions[protocol]


class ChannelsList:
    def __init__(self):
        self.channels = {}

    def create_channel(self, name):
        channel = self.channels.get(name)
        if not channel:
            self.channels[name] = channel = Channel()
        return channel

    def subscribe(self, name, protocol, number):
        channel = self.channels.get(name)
        if not channel:
            raise SubscriptionError('Unknown channel name')
        channel.subscribe(protocol, number)
        return channel


class CommunicationProtocol(BaseCommunicationProtocol):
    def __init__(self, loop, handler, channels=None, timeout=10):
        super(CommunicationProtocol, self).__init__(loop, timeout=timeout)
        self.handler = handler
        self.subscr_handlers = {}
        self.subscr_channels = {}
        self.subscr_requests = {}
        self.subscr_counter = 0
        self.channels = channels

    async def _process_request(self, data):
        try:
            request = pickle.loads(data)
            if not isinstance(request, CommunicationRequest):
                raise ProtocolRecoverableException('Wrong response class')
            if request.method.startswith('_'):
                raise ProtocolRecoverableException('Can`t call private method')
            method = getattr(self.handler, request.method, None)
            if not method:
                raise ProtocolRecoverableException('Unknown method name')
            if inspect.iscoroutinefunction(method):
                response = await method(*request.args, **request.kwargs)
            else:
                response = method(*request.args, **request.kwargs)
            return pickle.dumps(response)
        except BaseException as e:
            return pickle.dumps(e)

    async def make_request(self, method: str, *args, **kwargs):
        request = CommunicationRequest(method, args, kwargs)
        data = pickle.dumps(request)
        response = await self._make_request(data)
        response = pickle.loads(response)
        if isinstance(response, BaseException):
            raise response
        return response

    async def subscribe(self, channel: str, handler):
        self.subscr_counter += 1
        number = self.subscr_counter
        waiter = asyncio.Future(loop=self._loop)
        self.subscr_requests[number] = waiter
        self.write_message('asub', number, channel.encode('utf-8'))
        try:
            await asyncio.wait_for(waiter, self.timeout, loop=self._loop)
        finally:
            self.subscr_requests.pop(number, None)
        self.subscr_handlers[number] = handler
        return number

    def unsubscribe(self, number):
        del self.subscr_handlers[number]
        self.write_message('dsub', number, b'')

    async def comm_asub(self, number, data: bytes):
        """ Add subscription """
        channel = data.decode('utf-8')
        try:
            channel = self.channels.subscribe(channel, self, number)
            self.subscr_channels[number] = channel
        except BaseException as e:
            response = pickle.dumps(e)
        else:
            response = b'OK'
        self.write_message('csub', number, response)

    async def comm_csub(self, number, data):
        """ Confirm subscription """
        waiter = self.subscr_requests.get(number)
        if not waiter:
            return
        if data == b'OK':
            waiter.set_result(None)
        else:
            response = pickle.loads(data)
            waiter.set_exception(response)

    async def comm_dsub(self, number, data):
        """ Delete subscription """
        channel = self.subscr_channels.pop(number, None)
        if channel:
            channel.unsubscribe(self)

    def notify(self, number, data):
        self.write_message('nsub', number, data)

    async def comm_nsub(self, number, data):
        """ Notify subscription """
        if number in self.subscr_handlers:
            self.subscr_handlers[number](data)

    def close(self):
        for channel in self.subscr_channels.values():
            channel.unsubscribe(self)
        self.subscr_channels = {}
        for waiter in self.subscr_requests.values():
            waiter.cancel()
        self.subscr_requests = {}
        super(CommunicationProtocol, self).close()
