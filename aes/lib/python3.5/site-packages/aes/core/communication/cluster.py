import asyncio
import time


from .comm_protocol import ChannelsList


class CommunicationClusterNode:
    def __init__(self, name, protocol):
        self.name = name
        self._protocol = protocol
        self.connect_handlers = []
        if protocol:
            self.on_connect()

    @property
    def requestable(self) -> bool:
        return True

    def on_connect(self):
        for handler in self.connect_handlers:
            handler(self, self._protocol)

    @property
    async def protocol(self):
        if isinstance(self._protocol, asyncio.Future):
            self._protocol = await self._protocol
        return self._protocol

    @protocol.setter
    def protocol(self, value):
        if self._protocol:
            if isinstance(self._protocol, asyncio.Future):
                self._protocol.set_result(value)
            else:
                self._protocol.gracefully_close()
        self._protocol = value
        self.on_connect()

    def get_protocol(self):
        assert self._protocol
        assert not isinstance(self._protocol, asyncio.Future)
        return self._protocol

    def close(self):
        if self._protocol is None:
            return
        if isinstance(self._protocol, asyncio.Future):
            if not self._protocol.done():
                self._protocol.cancel()
        else:
            self._protocol.gracefully_close()
        self._protocol = None

    @property
    def connected(self):
        return (self._protocol and
                not isinstance(self._protocol, asyncio.Future))

    async def make_request(self, method, *args, **kwargs) -> dict:
        protocol = await self.protocol
        return await protocol.make_request(method, *args, **kwargs)


class CommunicationCluster(dict):
    def __init__(self, loop, timeout=60):
        super(CommunicationCluster, self).__init__()
        self.loop = loop
        self.timeout = timeout
        self._connect_callbacks = []
        self._shutdown_callbacks = []
        self.channels = ChannelsList()
        self.closed = False

    def add_connected_callback(self, func):
        self._connect_callbacks.append(func)

    def add_shutdown_callback(self, func):
        self._shutdown_callbacks.append(func)

    def add_node(self, node: CommunicationClusterNode):
        self[node.name] = node
        for func in self._connect_callbacks:
            func(node)

    def remove_node(self, node_name):
        node = self[node_name]
        del self[node_name]
        for func in self._shutdown_callbacks:
            func(node)
        return node

    async def request_node(self, name, method, *args, **kwargs) -> dict:
        response = {}
        start = time.time()
        try:
            response = await asyncio.wait_for(
                self[name].make_request(
                    method, *args, **kwargs
                ),
                self.timeout,
                loop=self.loop
            )
        except BaseException as e:
            response = {'success': False, 'error': repr(e)}
        else:
            response = {'success': True, 'response': response}
        finally:
            response['time'] = time.time() - start
        return response

    async def make_request(self, method, *args, **kwargs):
        tasks = {}
        start = time.time()
        for name, node in self.items():
            if node.requestable:
                tasks[name] = self.loop.create_task(
                    self.request_node(name, method, *args, **kwargs)
                )
        success = True
        response = {'responses': {}}
        for name, task in tasks.items():
            result = await task
            if success and not result['success']:
                success = False
            response['responses'][name] = result
        response['success'] = success
        response['time'] = time.time() - start
        return response

    def close(self):
        self.closed = True
        while self:
            _, node = self.popitem()
            node.close()
