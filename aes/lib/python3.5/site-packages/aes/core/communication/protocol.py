import asyncio
from functools import partial
import logging
import struct
import time

from aes.core.sentry import sentry_client

logger = logging.getLogger(__name__)


class ProtocolRecoverableException(Exception):
    pass


class ProtocolUnrecoverableException(Exception):
    pass


class OuterMethodException(Exception):
    pass


class BaseCommunicationProtocol(asyncio.StreamReaderProtocol):
    _limit = 2 ** 16
    timeout = 60
    _format = b'!LL'

    def __init__(self, loop, timeout=10):
        super(BaseCommunicationProtocol, self).__init__(
            stream_reader=asyncio.StreamReader(loop=loop, limit=self._limit),
            loop=loop
        )
        self.transport = None
        self.requests = {}
        self.request_number = 0
        self._execute_task = None
        self.closing = False
        self._exception = None
        self.close_waiter = asyncio.Future(loop=self._loop)
        self.last_updated = None
        self.timeout = timeout

    @property
    def exception(self):
        return self._exception

    def connection_made(self, transport):
        super(BaseCommunicationProtocol, self).connection_made(transport)
        self.transport = transport
        self._stream_writer = asyncio.StreamWriter(
            self.transport, self, self._stream_reader, self._loop
        )
        self._execute_task = self._loop.create_task(self.execute())
        self.last_updated = time.monotonic()

    def connection_lost(self, exc):
        super(BaseCommunicationProtocol, self).connection_lost(exc)
        self.close()
        if not self.close_waiter.done():
            self.close_waiter.set_result(None)

    async def _read_message(self):
        header = await asyncio.wait_for(
            self._stream_reader.readexactly(14),
            timeout=self.timeout,
            loop=self._loop)
        if header[0] != 0 or header[-1] != 0:
            # that is markers to understand that header not broken
            raise ProtocolUnrecoverableException('Message header is broken')
        command = header[1:5].decode('ascii')
        number, size = struct.unpack(self._format, header[5:13])
        data = await self._stream_reader.read(size)
        return command, number, data

    def write_message(self, command: str, number: int, data: bytes):
        header = b'\x00' + command.encode('ascii') + struct.pack(
            self._format, number, len(data)) + b'\x00'
        self._stream_writer.write(header)
        self._stream_writer.write(data)

    def _write_close_message(self):
        self._stream_writer.write(
            b'\x00QUIT' + struct.pack(self._format, 0, 0) + b'\x00')

    def gracefully_close(self):
        # make graceful close and return closing waiter future
        if not self.closing:
            self.closing = True
            self._write_close_message()
        return self.close_waiter

    async def graceful_close_requested(self):
        self.closing = True
        self._write_close_message()
        await self._stream_writer.drain()
        self.close()

    async def execute(self):
        while ((not self._stream_reader.at_eof())
               and self.transport):
            try:
                try:
                    command, number, data = await self._read_message()
                except asyncio.TimeoutError:
                    self.write_message('ping', 0, b'')
                    continue
                method = getattr(self, 'comm_' + command.lower(), None)
                if not method:
                    sentry_client.captureMessage('Unknown method in '
                                                 'communication')
                    logger.warning('Unknown method of packet in communication')
                else:
                    try:
                        self.last_updated = time.monotonic()
                        await method(number, data)
                    except Exception as e:
                        raise OuterMethodException from e
            except (ProtocolRecoverableException, OuterMethodException) as e:
                sentry_client.captureException()
                logger.exception(e)
            except BaseException as e:
                self._exception = e
                self.close()
                return

    async def comm_quit(self, number, data):
        if self.closing:
            self.close()
            return
        await self.graceful_close_requested()

    async def comm_rqst(self, number, data):
        response = await self._process_request(data)
        self.write_message('resp', number, response)

    async def comm_resp(self, number, data):
        if number not in self.requests:
            raise ProtocolRecoverableException(
                'Unexpected response number')
        future = self.requests[number]
        if not future.cancelled():
            future.set_result(data)
        del self.requests[number]

    async def comm_ping(self, number, data):
        self.write_message('pong', number, data)

    async def comm_pong(self, number, data):
        pass

    async def _process_request(self, data):
        raise NotImplementedError

    async def _make_request(self, data):
        future = asyncio.Future(loop=self._loop)
        self.request_number += 1
        number = self.request_number
        self.requests[number] = future
        self.write_message('rqst', number, data)
        result = await asyncio.wait_for(future, self.timeout, loop=self._loop)
        return result

    def close(self):
        while self.requests:
            _, waiter = self.requests.popitem()
            if waiter.done():
                continue
            if self._exception:
                waiter.set_exception(self._exception)
            else:
                waiter.cancel()
        if self.transport:
            self.transport.close()
            self.transport = None
        if self._execute_task:
            self._execute_task.cancel()
            self._execute_task = None

    @classmethod
    def factory(cls, loop, *args, **kwargs):
        """ Shortcut to create factory """
        return partial(cls, loop, *args, **kwargs)

    @classmethod
    async def connect_socket(cls, loop, sock, *args, **kwargs):
        _, protocol = await loop.create_connection(
            cls.factory(loop, *args, **kwargs),
            sock=sock
        )
        return protocol
