import asyncio
import socket
from unittest.mock import patch

from aes.message import SkipFlags
from aes.core.communication.cluster import (
    CommunicationClusterNode,
)
from aes.core.communication.comm_protocol import CommunicationProtocol
from aes.services.forks.process import AESProcess
from aes.services.prometheus.service import PrometheusService
from tests.core.services.forks import FakeForksService


class ForkTestService(FakeForksService):
    process = None
    comm_sock = None
    prometheus_sock = None

    def __init__(self, name, controller, config, loop):
        config = {'count': 1}
        super(ForkTestService, self).__init__(
            name, controller, config, loop)

    async def start(self):
        self.comm_sock, client = socket.socketpair()
        self.process = AESProcess(
            0, client, self.services, self.controller.settings)
        self.processes.append(self.process)
        protocol = await CommunicationProtocol.connect_socket(
            self.loop, self.comm_sock, None
        )
        self.cluster.add_node(CommunicationClusterNode(0, protocol))
        self.process.loop = self.loop
        self.process.prepare_loop = lambda x: None

    def run(self):
        self.process.run()

    def close(self):
        if self.comm_sock:
            self.comm_sock.close()
            self.comm_sock = None


def test_process(service_runner, simple_msg, loop):
    services = {'forks': ForkTestService, 'prometheus': PrometheusService}
    policy = {
        'white_black': dict(white=[{
            'template': simple_msg.mail_from,
            'bypass': SkipFlags.ANTIVIRUS | SkipFlags.SPAM
        }], black=[])
    }

    async def send_mail(loop, service, mail_from, mail_to, message):
        # server will spend some loop steps on initialization before server
        # will be created
        for _ in range(3):
            await asyncio.sleep(0, loop=loop)
        await service.send_message(mail_from, mail_to, message)
        loop.stop()
    runner = loop.run_until_complete(service_runner(add_services=services))
    runner['policy'].configure_user(simple_msg.mail_to, {'group': policy}, True)
    # check that prometheus not fail
    runner['prometheus'].client_socket.send(b'blabla\n')

    with patch('aes.services.prometheus.protocol.sentry_client') as sentry:
        with patch('aes.services.prometheus.protocol.logger') as logger:
            with patch('aes.services.forks.process.dictConfig'):
                runner.loop.create_task(
                    send_mail(
                        runner.loop,
                        runner['client'],
                        simple_msg.mail_from,
                        simple_msg.mail_to,
                        simple_msg.email
                    )
                )
                runner['forks'].run()
    assert len(runner['delivery_send'].mail_box) == 1
    # check that prometheus logged exception
    assert sentry.captureException.called
    assert logger.exception.called
    assert isinstance(logger.exception.call_args[0][0], KeyError)
