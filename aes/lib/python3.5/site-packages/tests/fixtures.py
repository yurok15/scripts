import asyncio
import email
from email.mime.application import MIMEApplication
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from functools import partial
from ipaddress import ip_address

import pytest

from aes.lib import EICAR, unused_socket
from aes.core.smtp.protocol import AESEnvelope
from aes.message import MessageInfo, SkipFlags
from aes.policy_service.policy import UserPolicy
from tests.core.runner import ServicesRunner


DEFAULT_SENDER = 'sender@intermedia.com'
DEFAULT_RECIPIENT = 'recipient@intermedia.com'


@pytest.fixture(scope='function', name='m_info_factory')
def m_info_factory_fixture():
    """ Factory to create message info from email.message """
    def factory(msg, policy=None, inbound=True):
        envelope = AESEnvelope(
            inbound=inbound,
            peer=('', 0),
            mail_from=DEFAULT_SENDER,
            data=msg.as_bytes())
        info = MessageInfo(envelope, DEFAULT_RECIPIENT)
        info.email = msg
        info.source_ip = ip_address('8.8.8.8')
        info.parse_attachments()
        user = DEFAULT_RECIPIENT if inbound else DEFAULT_SENDER
        info.policy = UserPolicy(None, user, [])
        info.policy.filtering = policy
        info.policy.domains = [user.split('@')[-1]]
        return info
    return factory


@pytest.fixture(scope='function', name='envelope')
def envelope_fixture():
    """ Default inbound SMTP envelope with user and peer"""
    return AESEnvelope(inbound=True, peer=('', 0), mail_from=DEFAULT_SENDER)


def set_default_headers(msg):
    msg['To'] = email.utils.formataddr(('Recipient', DEFAULT_RECIPIENT))
    msg['From'] = email.utils.formataddr(('Author', DEFAULT_SENDER))
    msg['Subject'] = 'Simple tests message'
    msg['X-SPF-STATUS'] = 'pass'
    msg['X-SOURCE-IP'] = '127.0.0.1'
    received = (
        'from mxout1.rambler.ru (mxout1.rambler.ru. [81.19.67.203])\n'
        '    by mx.google.com with ESMTP id '
        'fa6si1624012lbc.165.2016.03.08.07.03.14\n'
        '    for <handmadeone@gmail.com>;\n'
        '    Tue, 08 Mar 2016 07:03:14 -0800 (PST)'
    )
    msg['Received'] = received


@pytest.fixture(scope='function', name='msg')
def msg_fixture(m_info_factory, policy):
    """ Default message MessageInfo """
    msg = MIMEMultipart()
    set_default_headers(msg)
    text = MIMEText('This is message body.')
    msg.attach(text)
    return m_info_factory(msg, policy)


@pytest.fixture(scope='function')
def msg_outgoing(m_info_factory, policy):
    """ Default message MessageInfo """
    msg = MIMEMultipart()
    set_default_headers(msg)
    text = MIMEText('This is message body.')
    msg.attach(text)
    return m_info_factory(msg, policy, inbound=False)


@pytest.fixture(scope='function')
def msg_with_html(m_info_factory, policy, msg):
    """ Default message with HTML and HREF inside """
    mail = msg.email
    html = MIMEText(
        '<html><body><a href="http://example.com">example</a></body></html>',
        'html',
    )
    mail.attach(html)
    return m_info_factory(mail, policy)


@pytest.fixture(scope='function')
def msg_with_html_phishing(m_info_factory, policy, msg):
    """ Message with HTML and phishing href inside """
    mail = msg.email
    html = MIMEText(
        '<html><body>'
        '<a href="http://www.thisisaphishingurl.com/">example</a>'
        '</body></html>',
        'html',
    )
    mail.attach(html)
    return m_info_factory(mail, policy)


@pytest.fixture(scope='function')
def simple_msg(m_info_factory, policy):
    """ Simple not multipart MessageInfo """
    msg = MIMEText('hi')
    set_default_headers(msg)
    return m_info_factory(msg, policy)


@pytest.fixture(scope='function')
def no_filters_msg(m_info_factory):
    """ Simple not multipart message with empty policy """
    msg = MIMEText('hi')
    set_default_headers(msg)
    return m_info_factory(msg, {'group': {'filters': {}}})


@pytest.fixture(scope='function')
def no_filters_msg_outgoing(m_info_factory):
    msg = MIMEText('hi')
    set_default_headers(msg)
    return m_info_factory(msg, {'group': {'filters': {}}}, inbound=False)


@pytest.fixture(scope='function')
def msg_with_virus(msg, virus, m_info_factory):
    """ Simple message with EICAR virus """
    msg.email.attach(virus)
    return m_info_factory(msg.email, msg.policy.filtering, inbound=False)


@pytest.fixture(scope='function')
def msg_with_virus_exe(msg, virus_exe):
    """ Simple message with EICAR virus and EXE extension """
    msg.email.attach(virus_exe)
    msg.parse_attachments()
    msg.raw_data = msg.email.as_bytes()
    return msg


@pytest.fixture(scope='function')
def msg_dangerous_attachments(msg):
    """ Message with some dangerous attachments names"""
    _exe = MIMEApplication(b'')
    _exe.add_header('Content-Disposition', 'attachment',
                    filename="attach_deny.exe")
    msg.email.attach(_exe)
    _dll = MIMEApplication(b'')
    _dll.add_header('Content-Disposition', 'attachment',
                    filename="attach_deny.dll")
    msg.email.attach(_dll)
    _cmd = MIMEApplication(b'')
    _cmd.add_header('Content-Disposition', 'attachment',
                    filename="attach_deny.cmd")
    msg.email.attach(_cmd)
    msg.parse_attachments()
    msg.raw_data = msg.email.as_bytes()
    return msg


@pytest.fixture(scope='function', name='virus')
def virus_fixture():
    """ EICAR virus attachment """
    return MIMEApplication(EICAR)


@pytest.fixture(scope='function', name='virus_exe')
def virus_exe_fixture():
    """ EICAR virus attachment with EXE extention """
    _attach = MIMEApplication(EICAR)
    _attach.add_header('Content-Disposition', 'attachment',
                       filename="virus.exe")
    return _attach


@pytest.fixture(name='policy')
def policy_fixture():
    """ Simple default policy """
    return {
        'group': {
            'spam': {
                'classification': [
                    {
                        'min_score': 100,
                        'actions': []
                    },
                    {
                        'min_score': 500,
                        'actions': [{'name': 'deny_delivery'}]
                    },
                ]
            },
            'white_black': {
                'white': [
                    {
                        'template': '162.244.196.77',
                        'bypass': SkipFlags.ATTACHMENTS | SkipFlags.SPF,
                    }
                ]
            },
            'antivirus': {
                'actions': [{'name': 'deny_delivery'}],
            },
            'attachments': {
                'extensions': {
                    '.bat': {'action': 'deny_delivery'},
                    '.exe': {'action': 'deny_delivery'},
                },
            },
            'url_protection': {},
        }
    }


@pytest.yield_fixture(scope='function')
def tcp_service_factory(loop):
    """ Factory to create simple asyncio server """
    server = None

    async def service_factory(callback):
        host, port = unused_socket().getsockname()
        nonlocal server
        server = await loop.create_server(
            partial(
                asyncio.StreamReaderProtocol,
                asyncio.StreamReader(loop=loop),
                callback,
                loop=loop,
            ),
            host=host,
            port=port,
        )
        server.host = host
        server.port = port
        return server
    yield service_factory
    if server:
        server.close()


@pytest.yield_fixture
def service_runner(loop):
    runner = None

    async def factory(**kwargs):
        nonlocal runner
        assert runner is None
        runner = ServicesRunner(loop=loop, **kwargs)
        await runner.start()
        return runner
    yield factory
    if runner:
        runner.close()


@pytest.fixture
def host_and_free_port():
    return unused_socket('127.0.0.1').getsockname()
