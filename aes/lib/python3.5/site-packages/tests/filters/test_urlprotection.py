from base64 import b64encode as encode_b64
from quopri import encodestring as encode_q

import pytest

from aes.filters.urlprotection.filter import (
    UrlProtectionFilter,
    template_to_expression,
)
from aes.core.exceptions import ImproperlyConfigured
from aes.message import MessageInfo, AttachInfo, Category
from aes.lib.encoders import AESEncoder
from aes.lib.mime import encode_uu

RESOLVER_URL = 'http://resolver'


def get_filter(loop, config=None):
    return UrlProtectionFilter(
        'urlprotection',
        None,
        config or {
            'urlresolver_url': RESOLVER_URL,
            'secret_key': 'lORSLyxpMKrLCwadEiNbCiUtTOwipGVC',
        },
        loop,
    )


def test_bad_configuration(loop):
    with pytest.raises(ImproperlyConfigured):
        get_filter(loop, {'urlresolver_url': RESOLVER_URL})

    with pytest.raises(ImproperlyConfigured):
        get_filter(loop, {'secret_key': 'lORSLyxpMKrLCwadEiNbCiUtTOwipGVC'})

    with pytest.raises(ImproperlyConfigured):
        get_filter(loop, {'secret_key': 'SLyxpMKrLCwadEiNbCiUtTOwipGVC',
                          'urlresolver_url': RESOLVER_URL})


async def test_replace_in_html_part(msg_with_html, loop):
    f = get_filter(loop)
    await f.process(
        msg_with_html,
        {'global': {'white_list': []}, 'group': None},
    )
    assert RESOLVER_URL in msg_with_html.email.as_string()


async def test_not_replace_when_white_listed(msg_with_html, loop):
    f = get_filter(loop)
    await f.process(
        msg_with_html,
        {'global': {'white_list': ['example.com']}},
    )
    assert RESOLVER_URL not in msg_with_html.email.as_string()


async def test_replace_in_text_part(msg, loop):
    f = get_filter(loop)
    msg.attachments[0].attach.set_payload('some www.example.com link')
    await f.process(
        msg,
        {'group': {'white_list': []}},
    )
    assert RESOLVER_URL in msg.email.as_string()


matching_cases = [
    (
        'example.com',
        'http://example.com',
    ),
    (
        'example.com',
        'http://example.com/path',
    ),
    (
        'example.com',
        'https://example.com',
    ),
    (
        'example.com',
        'https://example.com/path',
    ),
    (
        'example.com',
        'ftp://example.com',
    ),
    (
        'example.com',
        'http://sub.example.com',
    ),
    (
        'http://example',
        'http://example',
    ),
    (
        'http://example',
        'http://example/pat/path',
    ),
    (
        '*example.com',
        'http://myexample.com',
    ),
    (
        '*example.com',
        'http://otherexample.com',
    ),
    (
        'example.*',
        'http://example.mysite.com',
    ),
    (
        'example.*',
        'http://example.othersite.com',
    ),
    (
        'example.*',
        'http://example.com',
    ),
    (
        'example.*',
        'http://example.net',
    ),
    (
        'example.*',
        'http://example.org',
    ),
    (
        'example.*',
        'http://my.example.org',
    ),
    (
        'example.*',
        'http://my.example.org/path',
    ),
    (
        '*://*.com/someaddress?*&id=*',
        'http://sub2.sub1.example.com/someaddress?a=1&b=2&id=3',
    ),
]
not_matching_cases = [
    (
        'example.com',
        'http://notexample.com',
    ),
    (
        '*.example.com',
        'http://example.com',
    ),
    (
        'example.com/path',
        'http://example.com/otherpath',
    ),
    (
        'http://example.com',
        'http://sub.example.com',
    ),
]


@pytest.mark.parametrize('template,url',
                         matching_cases)
async def test_exp_conversion_matching(template, url):
    assert template_to_expression(template).match(url)


@pytest.mark.parametrize('template,url',
                         not_matching_cases)
async def test_exp_conversion_not_matching(template, url):
    assert not template_to_expression(template).match(url)


@pytest.mark.parametrize('content_type,body,expected', [
    ('text/html; charset=utf-8',
     '<a href="http://google.com">link</a>',
     RESOLVER_URL),
    ('text/plain; charset=utf-8',
     'http://google.com',
     RESOLVER_URL),
    ('text/php',
     'http://google.com',
     'http://google.com'),
    ('multipart/mixed',
     'http://google.com',
     'http://google.com'),
    ('text/plain',
     'http://goo\udcc2gle.com',
     'http://goo\udcc2gle.com'),
    ('text/html',
     '<a href="http://goo\udcc2gle.com">link</a>',
     'http://goo\udcc2gle.com'),
    ('text/html',
     '<a href="http://your.website.address.here]195">link</a>',
     'http://your.website.address.here]195'),
    ('text/plain',
     'plain http://your.website.address.here]195 plain',
     'http://your.website.address.here]195'),
    ('text/html',
     '<a href="#123">link</a>',
     '#123'),
    ('text/html',
     '<a href ="testetstest&&&#x0000F">ya.ru</a>',
     '<a href ="testetstest&&&#x0000F">ya.ru</a>'),
    ('text/html',
     '<a href="ftps#x0002F;&#x0002F;ya&#x0002E;ru">link</a>',
     '<a href="ftps#x0002F;&#x0002F;ya&#x0002E;ru">link</a>'),
    ('text/html',
     '<a href="link.ru">link</a>',
     RESOLVER_URL),
    ('text/html',
     '<a href=".link">link</a>',
     '<a href=".link">'),
    ('text/html',
     '<a href="127.0.0.1/link">link</a>',
     RESOLVER_URL),
    ('text/html',
     '<a href="http://link">link</a>',
     RESOLVER_URL),
    ('text/html',
     '<A HREF="http://link">link</a>',
     RESOLVER_URL),
    ('text/html',
     '<A HREF="http://link\n.com">link</a>',
     RESOLVER_URL),
])
async def test_non_multipart_message(loop, content_type, body, expected,
                                     envelope):
    raw_msg = [
        'To: to@mail',
        'From: from@mail',
        'Content-Type: ' + content_type,
        'MIME-Version: 1.0',
        '',
        body
    ]
    envelope.original_content = bytearray('\r\n'.join(raw_msg).encode(
        encoding='utf-8', errors='surrogateescape'))
    msg = MessageInfo(envelope, 'to@mail')
    msg.parse_message()
    f = get_filter(loop)
    result = await f.process(
        msg,
        {'group': {'white_list': []}},
    )
    if expected == RESOLVER_URL:
        assert result == 'links: 1'
    else:
        assert result is None
    assert expected in msg.email.as_string()


async def test_attachment_not_is_body(msg_with_html, loop):
    attach = msg_with_html.attachments[0].attach
    payload = attach.get_payload()
    msg_with_html.attachments.append(
        AttachInfo(msg_with_html, payload, attach, [3]))
    f = get_filter(loop)
    await f.process(
        msg_with_html,
        {'global': {'white_list': []}},
    )
    assert RESOLVER_URL in msg_with_html.email.as_string()


RESOLVED_URL = RESOLVER_URL + '/?aLINK'


class FakeEncoder:
    @staticmethod
    def encode(_):
        return 'LINK'


@pytest.mark.parametrize('ct,ce,cte,body,expected', [
    (
        b'text/plain', b'cp1251', b'base64',
        encode_b64(
            b'\xf2\xe5\xf1\xea\xf2 3@# https://www.google.com'),
        encode_b64(
            b'\xf2\xe5\xf1\xea\xf2 3@# ' +
            RESOLVED_URL.encode('cp1251')),
    ),
    (
        b'text/plain', b'cp1251', b'quoted-printable',
        encode_q(
            b'\xf2\xe5\xf1\xea\xf2 https://www.google.com 3@#'),
        encode_q(
            b'\xf2\xe5\xf1\xea\xf2 ' +
            RESOLVED_URL.encode('cp1251') + b' 3@#\r\n'),
    ),
    (
        b'text/plain', b'foobar', b'base64',
        encode_b64(
            b'\xf2\xe5\xf1\xea\xf2 3@# https://www.google.com'),
        encode_b64(
            b'\xf2\xe5\xf1\xea\xf2 3@# ' + RESOLVED_URL.encode()),
    ),
    (
        b'text/plain', b'cp-850', b'base64',
        encode_b64(
            b'\xf2\xe5\xf1\xea\xf2 3@# https://www.google.com'),
        encode_b64(
            b'\xf2\xe5\xf1\xea\xf2 3@# ' + RESOLVED_URL.encode('cp850')),
    ),
    (
        b'text/plain', b'binary', b'base64',
        encode_b64(
            b'\xf2\xe5\xf1\xea\xf2 3@# https://www.google.com'),
        encode_b64(
            b'\xf2\xe5\xf1\xea\xf2 3@# ' + RESOLVED_URL.encode('cp850')),
    ),
    (
        b'text/plain', b'cp1251', b'BASE64',
        encode_b64(
            b'\xf2\xe5\xf1\xea\xf2 3@# https://www.google.com'),
        encode_b64(
            b'\xf2\xe5\xf1\xea\xf2 3@# ' + RESOLVED_URL.encode('utf-8')),
    ),
    (
        b'text/plain', b'cp1251', b'uuencode',
        encode_uu(
            b'\xf2\xe5\xf1\xea\xf2 3@# https://www.google.com'),
        encode_uu(
            b'\xf2\xe5\xf1\xea\xf2 3@# ' + RESOLVED_URL.encode('utf-8')),
    ),
    (
        b'text/html', b'iso2022_jp', b'7bit',
        b'<a href="http://123direct.jp/tracking/cr/SXvnhb41/246367/7840955?' +
        b'p= 69650&ts=mag_dann_170305">\x1b$BH</a>',
        b'<a href="' + RESOLVED_URL.encode('utf-8') + b'">\x1b$BH</a>\r\n',
    ),
    (
        b'text/plain', b'base64', b'7bit',
        b'https://www.google.com',
        RESOLVED_URL.encode('utf-8') + b'\r\n',
    ),
    (
        b'text/plain', b'base64', b'\xff',
        b'https://www.google.com',
        RESOLVED_URL.encode('utf-8') + b'\r\n',
    ),
])
async def test_encodings_multipart(loop, ct, ce, cte, body,
                                   expected, envelope):
    raw_msg = [
        b'Content-Type: multipart/mixed; boundary="===============0327234455=="',
        b'MIME-Version: 1.0',
        b'from: aesTestMailUrlProtection@mail.ru',
        b'to: aesTest@imqa-aesTest.qahostpilot.com',
        b'date: Thu, 12 Jan 2017 23:17:17 +0300',
        b'Message-ID: <148425223712.11744.6957693222667823244.C78JYQU1XZ@test>',
        b'',
        b'--===============0327234455==',
        b'Content-Type: ' + ct + b'; charset=' + ce,
        b'MIME-Version: 1.0',
        b'Content-Transfer-Encoding: ' + cte,
        b'',
        body,
        b'',
        b'--===============0327234455==',
        b'Content-Type: application/exe',
        b'MIME-Version: 1.0',
        b'Content-Transfer-Encoding: quoted-printable',
        b'Content-Disposition: attachment; filename="testAttach.exe"',
        b'',
        b'ZGF0YQ==',
        b'',
        b'--===============0327234455==--',
        b''
    ]
    envelope.original_content = b'\r\n'.join(raw_msg)
    msg = MessageInfo(envelope, 'to@mail')
    msg.parse_message()
    f = get_filter(loop)
    f.encoder = FakeEncoder()
    await f.process(
        msg,
        {'group': {'white_list': []}},
    )
    assert msg.attachments[0].attach._payload == expected.decode()


@pytest.mark.parametrize('content_type,transfer_encoding,body,expected', [
    (
        b'text/plain; charset="cp1251"',
        b'base64',
        encode_b64(
            b'\xf2\xe5\xf1\xea\xf2 j3@# https://www.google.com'),
        encode_b64(
            b'\xf2\xe5\xf1\xea\xf2 j3@# ' + RESOLVED_URL.encode('cp1251'))
    ),
    (
        b'text/plain; charset="cp1251"',
        b'quoted-printable',
        encode_q(
            b'\xf2\xe5\xf1\xea\xf2 j3@# https://www.google.com'),
        encode_q(
            b'\xf2\xe5\xf1\xea\xf2 j3@# ' + RESOLVED_URL.encode('cp1251'))
    ),
    (
        b'text/html; charset="utf-8"',
        b'7bit',
        b'<a href="mailto:mailbox@mail.ru">mailto</a>',
        b'<a href="mailto:mailbox@mail.ru">mailto</a>',
    ),
    (
        b'TEXT/PLAIN; charset="cp1251"',
        b'QUOTED-PRINTABLE',
        encode_q(
            b'\xf2\xe5\xf1\xea\xf2 j3@# https://www.google.com'),
        encode_q(
            b'\xf2\xe5\xf1\xea\xf2 j3@# ' + RESOLVED_URL.encode('cp1251'))
    ),
    (
        b'text/plain; charset="utf-8"',
        b'X-UUE',
        encode_uu(
            b'plain j3@# https://www.google.com'),
        encode_uu(
            b'plain j3@# ' + RESOLVED_URL.encode('cp1251'))
    ),
    (
        b'text/plain; charset="utf-8"',
        b'X-UUE',
        b'plain j3@# https://www.google.com',
        encode_uu(b'plain j3@# ' + RESOLVED_URL.encode('cp1251'))
    ),
])
async def test_encodings_non_multipart(loop, content_type, transfer_encoding,
                                       body, expected, envelope):
    raw_msg = [
        b'To: to@mail',
        b'From: from@mail',
        b'Content-Type: ' + content_type,
        b'Content-Transfer-Encoding: ' + transfer_encoding,
        b'MIME-Version: 1.0',
        b'',
        body
    ]
    envelope.original_content = b'\r\n'.join(raw_msg)
    msg = MessageInfo(envelope, 'to@mail')
    msg.parse_message()
    f = get_filter(loop)
    f.encoder = FakeEncoder()
    await f.process(
        msg,
        {'group': {'white_list': []}},
    )
    assert expected.decode() == msg.email._payload


@pytest.mark.parametrize('link', [
    'https://yandex.ru/search/?msid=14.91826.22892.8980&text=qwewq&lr=2',
    'http://domain.com.vn/c728/s728-49/on-200-web-vn-bi-hack-chi-ng-1-dem.htm',
    'http://forum.bkav.com.vn/thread.php?27505-Giai-ma-hien-tuong-website',
    'http://news.google.com/news?hl=en&ned=us&q=vietnam&ie=UTF-8&start=0&sa=N',
    'http://q.163.com',
    'http://vi.wikipedia.org/wiki/Qu%E1%BA%A7n_%C4%91%E1%BA%A3o_Sa',
    'http://zh.wikipedia.org/wiki/%E5%8D%97%E6%B2%99%E7%BE%A4%E5%B2%9B',
    'http://www.youtube.com/watch?v=z1HRwkxh3M8&feature=related'
    'https://wiki.intermedia.net:8443/display/UX/NextGen%3A+Updates%3A+UI'
])
async def test_encoding_url_with_args(loop, link):
    encoder = AESEncoder('lORSLyxpMKrLCwadEiNbCiUtTOwipGVC')
    expected = RESOLVER_URL + '/?a' + encoder.encode(link)
    f = get_filter(loop)
    result = f._encode(link)
    assert expected == result
    assert link == encoder.decode(result[len(RESOLVER_URL) + 3:])


@pytest.mark.parametrize('ct_0,ct_1,ct_2,expected', [
    (b'text/plain', b'text/plain', b'text/plain', [True, False, False]),
    (b'text/html', b'text/plain', b'text/plain', [True, True, False]),
    (b'text/plain', b'text/html', b'text/plain', [True, True, False]),
    (b'text/html', b'text/html', b'text/plain', [True, False, False]),
])
async def test_body_determination_linear(loop, ct_0, ct_1, ct_2, expected,
                                         envelope):
    html_body = b'<a href="http://link.com">link</a>'
    plain_body = b'http://link.com'
    raw_msg = [
        b'Content-Type: multipart/mixed; boundary="===============0327234455=="',
        b'MIME-Version: 1.0',
        b'from: aesTestMailUrlProtection@mail.ru',
        b'to: aesTest@imqa-aesTest.qahostpilot.com',
        b'date: Thu, 12 Jan 2017 23:17:17 +0300',
        b'Message-ID: <148425223712.11744.6957693222667823244.C78JYQU1XZ@test>',
        b'',
        b'--===============0327234455==',
        b'Content-Type: ' + ct_0 + b'; charset="utf-8"',
        b'MIME-Version: 1.0',
        b'',
        plain_body if ct_0 == b'palin/text' else html_body,
        b'',
        b'--===============0327234455==',
        b'Content-Type: ' + ct_1 + b'; charset="utf-8"',
        b'MIME-Version: 1.0',
        b'',
        plain_body if ct_1 == b'palin/text' else html_body,
        b'',
        b'--===============0327234455==',
        b'Content-Type: ' + ct_2 + b'; charset="utf-8"',
        b'MIME-Version: 1.0',
        b'',
        plain_body if ct_2 == b'palin/text' else html_body,
        b'',
        b'--===============0327234455==--',
        b''
    ]
    envelope.original_content = b'\r\n'.join(raw_msg)
    msg = MessageInfo(envelope, 'to@mail')
    msg.parse_message()
    f = get_filter(loop)
    f.encoder = FakeEncoder()
    await f.process(
        msg,
        {'group': {'white_list': []}},
    )
    for i in range(3):
        assert (RESOLVED_URL in
                msg.attachments[i].attach._payload) == expected[i]


async def test_body_determination_tree(loop, envelope):
    raw_msg = \
"""MIME-Version: 1.0
From: <sender@mail>
To: <receipient@mail>
Content-Type: multipart/alternative; boundary=0001\r\n
--0001
Content-Type: text/plain; charset=utf-8\r\n
http://plain.text.link\r\n
--0001
Content-Type: multipart/related; type="text/html"; boundary=--0002\r\n
----0002
Content-Type: text/html; charset=utf-8\r\n
<a href="http://link.html">html link 2</a>\r\n
----0002
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-ID: <company-logo>\r\n
iVBORw0KGgoAAAANSUhEUgAAAEcAAAAoCAYAAACsEueQAAAAAXNSR0IArs4c6QAAAARn\r\n
----0002--\r\n
----0001--\r\n"""
    envelope.original_content = raw_msg.encode()
    msg = MessageInfo(envelope, 'to@mail')
    msg.parse_message()
    f = get_filter(loop)
    f.encoder = FakeEncoder()
    await f.process(
        msg,
        {'group': {'white_list': []}},
    )
    assert RESOLVED_URL in msg.attachments[0].attach._payload
    assert RESOLVED_URL in msg.attachments[1].attach._payload


async def test_quarantine_category(msg_with_html, simple_msg, service_runner):
    settings = {
        'FILTERS': [
            ('url_protection', {
                'class': 'aes.filters.UrlProtectionFilter',
                'urlresolver_url': 'http://devaes-vx-1:80',
                'secret_key': 'lORSLyxpMKrLCwadEiNbCiUtTOwipGVC',
                'links_limit': 1,
            })
        ]
    }
    runner = await service_runner(settings=settings)

    msg_with_html.attachments[1].attach.set_payload(
        '<a href="http://link.com">link</a>' * 2)
    await runner.run_info(msg_with_html)
    msg = runner['quarantine']['admin'].mail_box[0].message
    assert msg['X-AES-Category'] == Category.ERROR

    simple_msg.email.set_payload('http://link.com' * 2)
    await runner.run_info(simple_msg)
    msg = runner['quarantine']['admin'].mail_box[0].message
    assert msg['X-AES-Category'] == Category.ERROR
