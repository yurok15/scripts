from unittest.mock import patch
from collections import OrderedDict

import pytest

from aes.filters.controller import FilterController
from aes.filters.base import BaseFilter


class BrokenFilter(BaseFilter):
    async def process(self, message, test=None):
        raise NotImplementedError


def get_controller(loop, config=None):
    config = config or {
        'test': {'class': BrokenFilter}
    }
    return FilterController('', None, config, loop)


async def test_filter_disabling(msg, loop):
    controller = get_controller(loop)
    msg.policy.filtering = {
        'group': {
            'test': {'disabled': True}
        }
    }
    await controller.apply(msg)


async def test_filter_unexpected_exception(msg, loop):
    msg.policy.filtering = {
        'group': {
            'test': {}
        }
    }
    controller = get_controller(loop)
    with pytest.raises(NotImplementedError):
        with patch('aes.filters.controller.sentry_client') as sentry:
            with patch('aes.filters.controller.logger') as logger:
                await controller.apply(msg)
    assert sentry.captureException.called
    assert logger.exception.called


SKIP_FLAG = 1 << 9

class SkipperFilter(BaseFilter):
    skip_flag = SKIP_FLAG
    async def process(self, message, test=None):
        skips = test.get('skips', 0)
        if skips:
            message.skip_filters |= skips
        else:
            raise NotImplementedError


async def test_multi_policies(msg, loop):
    class SimpleFilter(BaseFilter):
        calls = []

        @classmethod
        async def process(cls, message, simple=None):
            cls.calls.append(simple)

    class MultiFilter(SimpleFilter):
        allow_multiple_policy = True
        calls = []

        @classmethod
        async def process(cls, message, multi=None):
            cls.calls.append(multi)

    config = OrderedDict([
        ('simple', {'class': SimpleFilter}),
        ('multi', {'class': MultiFilter}),
    ])
    controller = get_controller(loop, config)
    config = OrderedDict()
    names = ['1', '2', '3']
    for name in names:
        config[name] = {
            'simple': {'value': 's_' + name},
            'multi': {'value': 'm_' + name},
        }
    msg.policy.filtering = config
    await controller.apply(msg)
    assert SimpleFilter.calls == [{'value': 's_' + i} for i in names]
    assert len(MultiFilter.calls) == 1
    for i, (name, value) in enumerate(MultiFilter.calls[0].items()):
        assert name == names[i]
        assert value == {'value': 'm_' + names[i]}


async def test_skip_down_level_filter(msg, loop):
    config = {'test': {'class': SkipperFilter}}
    controller = get_controller(loop, config)
    group_policy = {
        'test': {}
    }
    msg.policy.filtering = {'group': group_policy}
    with pytest.raises(NotImplementedError):
        with patch('aes.filters.controller.sentry_client') as sentry:
            with patch('aes.filters.controller.logger') as logger:
                await controller.apply(msg)
    assert sentry.captureException.called
    assert logger.exception.called
    global_policy = {
        'test': {'skips': SKIP_FLAG}
    }
    msg.policy.filtering = OrderedDict([
        ('global', global_policy),
        ('group', group_policy)
    ])
    await controller.apply(msg)


@pytest.mark.parametrize('multiple_policy', [True, False])
async def test_filter_without_category(loop, msg, multiple_policy):
    class FooFilter(BaseFilter):
        allow_multiple_policy = multiple_policy

        async def process(self, message, **kwargs):
            message.test = 'bar'

    config = {'foo': {'class': FooFilter}}
    controller = get_controller(loop, config)
    await controller.apply(msg)

    assert getattr(msg, 'test', 'missed') == 'bar'
    assert controller['foo'].categories == []
