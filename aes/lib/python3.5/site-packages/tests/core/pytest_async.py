import inspect
import asyncio
import logging
from functools import wraps

import pytest

from aes.core.loop import finalize_loop

logger = logging.getLogger(__name__)

LOOP_FIXTURE = 'loop'
ALLOW_DEFAULT_LOOP_MARK = 'allow_default_loop'


@pytest.fixture(name='loop')
def loop_fixture(request):
    """Create an instance of the default event loop for each test case."""
    policy = asyncio.get_event_loop_policy()
    l = policy.new_event_loop()
    l.fixture_request = request
    old_loop = asyncio.get_event_loop()
    allow_default = ALLOW_DEFAULT_LOOP_MARK in request.keywords
    asyncio.set_event_loop(l if allow_default else None)
    l.set_debug(True)

    def fin():
        try:
            finalize_loop(l)
            all_tasks = asyncio.Task.all_tasks(loop=l)
            pending = [f for f in all_tasks if not f.done()]

            for task in pending:
                logger.error('Pending task found: %s', repr(task))
                task.cancel()
            l.close()
        finally:
            asyncio.set_event_loop(old_loop)

    request.addfinalizer(fin)
    return l


def async_decorator(func, item):
    @wraps(func)
    def wrapper(*args, **kwargs):
        loop = item.funcargs[LOOP_FIXTURE]
        assert inspect.iscoroutinefunction(func)
        loop.run_until_complete(func(*args, **kwargs))
    return wrapper


def pytest_runtest_setup(item):
    if (hasattr(item, 'obj')
            and inspect.iscoroutinefunction(item.obj)):
        if LOOP_FIXTURE not in item.fixturenames:
            # inject an event loop fixture for all async tests
            item.fixturenames.append(LOOP_FIXTURE)
        item.obj = async_decorator(item.obj, item)


def pytest_addoption(parser):
    group = parser.getgroup('logging', 'Logging Configuration')
    group.addoption('--log_level',
                    dest='log_level',
                    default='WARNING',
                    help='Logging level - DEBUG, INFO, WARNING, ERROR')
    parser.addini('log_level',
                  'Logging level - DEBUG, INFO, WARNING, ERROR')


def pytest_configure(config):
    level = config.getini('log_level') or config.getvalue('log_level')
    if level not in logging._nameToLevel:
        raise Exception('Invalid log level: %s', level)
    level_value = logging._nameToLevel[level]
    logging.basicConfig(level=level_value)
