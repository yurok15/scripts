import copy
import logging
from collections import OrderedDict

import asyncio
from aes.conf import Settings
from aes.core.controller import ServicesController
from aes.services import (
    ClamAVFakeService,
    VadeRetroFakeService,
    EmailSenderService,
)
from .services import (
    InboundAESTestService,
    OutboundAESTestService,
    FilteringTestService,
    HttpTestService,
    PolicyTestService,
    QuarantineController,
    MemoryAnalyticsService,
)
from .services.smtp import (
    NDRDelivery,
    SendDelivery,
    DenyDelivery,
)


class ServiceInfo:
    port = None
    service = None


class ServicesRunner(ServicesController):
    default_services = OrderedDict([
        ('http', HttpTestService),
        ('policy', PolicyTestService),
        ('delivery_send', SendDelivery),
        ('quarantine', QuarantineController),
        ('delivery_deny', DenyDelivery),
        ('delivery_ndr', NDRDelivery),
        ('vade_retro', VadeRetroFakeService),
        ('clamav', ClamAVFakeService),
        ('filtering', FilteringTestService),
        ('inbound_smtp', InboundAESTestService),
        ('outbound_smtp', OutboundAESTestService),
        ('client', EmailSenderService),
        ('analytics', MemoryAnalyticsService),
    ])

    def __init__(self, settings=None, services=None, loop=None,
                 add_services=None):
        loop = loop or asyncio.new_event_loop()
        loop.set_exception_handler(self.loop_exception_handler)
        available_services = services or self.default_services.copy()
        if add_services:
            available_services.update(add_services)
        self.settings = Settings()
        if settings:
            self.settings.update(settings)
        self.settings = copy.deepcopy(self.settings)
        self.settings['AUTO_ENABLE_TEST_SERVICES'] = True
        self._closed = False
        services = OrderedDict()
        for name, value in available_services.items():
            services[name] = {'class': value}
        super(ServicesRunner, self).__init__(
            self.settings, services, loop)

    @staticmethod
    def loop_exception_handler(_, context):
        logging.exception(str(context))

    async def run(self, mail_from, mail_tos, message, inbound=True, timeout=10):
        if not self.started.done():
            await self.start()
        return await asyncio.wait_for(
            self['client'].send_message(mail_from, mail_tos, message, inbound),
            timeout,
            loop=self.loop
        )

    async def run_with_policy(self, message, policy, inbound=True, timeout=20):
        email = 'recipient@local' if inbound else 'sender@local'
        self['policy'].configure_user(email, {'group': policy}, inbound)
        await self.run('sender@local', ['recipient@local'], message,
                       inbound, timeout)

    async def run_info(self, message_info, inbound=True, timeout=10):
        if message_info.policy and message_info.policy.filtering:
            policy = message_info.policy.filtering.copy()
            if 'global' in policy:
                if inbound:
                    global_policy = self['policy'].inbound_global_policy
                else:
                    global_policy = self['policy'].outbound_global_policy
                global_policy.data = policy.pop('global')
            email = message_info.mail_to if inbound else message_info.mail_from
            self['policy'].configure_user(email, policy, inbound)
        return await self.run(
            message_info.mail_from,
            [message_info.mail_to],
            message_info.email,
            inbound,
            timeout
        )
