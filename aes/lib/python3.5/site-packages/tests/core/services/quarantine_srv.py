import asyncio
from base64 import b64decode
from json import loads, JSONDecodeError
from binascii import Error as BinASCIIError

from aiosmtplib.smtp import MAX_LINE_LENGTH
from aiosmtplib.errors import SMTPException, SMTPDataError, SMTPConnectError

from aes.core.smtp.protocol import SMTPProtocol
from aes.core.controller import BaseController
from aes.delivery.quarantine import (
    AdminQuarantineDelivery,
    UserQuarantineDelivery,
)
from tests.core.services.smtp import BaseFakeSMTPServer
from .policy import PolicyTestService


__ident__ = 'Test SMTP with AESREPORT ext'


DATA_SIZE_DEFAULT = 102400


class ExSMTP(SMTPProtocol):
    HELP = {
        'EHLO': '250 Syntax: EHLO hostname',
        'HELO': '250 Syntax: HELO hostname',
        'DATA': '250 Syntax: DATA',
        'RSET': '250 Syntax: RSET',
        'NOOP': '250 Syntax: NOOP',
        'QUIT': '250 Syntax: QUIT',
        'VRFY': '250 Syntax: VRFY <address>',
        'AESREPORT': '250 Syntax: AESREPORT',
    }

    @asyncio.coroutine
    def ehlo_hook(self):
        yield from self.push('250-AESREPORT')

    @asyncio.coroutine
    def smtp_HELP(self, arg):
        if arg:
            extended = ' [SP <mail-parameters>]'
            lc_arg = arg.upper()
            if lc_arg in self.HELP:
                yield from self.push(self.HELP[lc_arg])
            elif lc_arg == 'MAIL':
                msg = '250 Syntax: MAIL FROM: <address>'
                if self.extended_smtp:
                    msg += extended
                yield from self.push(msg)
            elif lc_arg == 'RCPT':
                msg = '250 Syntax: RCPT TO: <address>'
                if self.extended_smtp:
                    msg += extended
                yield from self.push(msg)
            else:
                yield from self.push(
                    '501 Supported commands: EHLO HELO MAIL RCPT '
                    'DATA RSET NOOP QUIT VRFY AESREPORT')
        else:
            yield from self.push(
                '250 Supported commands: EHLO HELO MAIL RCPT DATA '
                'RSET NOOP QUIT VRFY AESREPORT')

    async def smtp_AESREPORT(self, arg):
        if arg:
            await self.push('501 Syntax: AESREPORT')
            return

        await self.push('354 Continue')

        try:
            data = part = b''
            while part != b'\r\n':
                part = await self._reader.readline()
                if not part:
                    raise SMTPDataError

                if len(part) > MAX_LINE_LENGTH:
                    raise SMTPDataError(500, 'Line too long')

                data += part.rstrip(b'\r\n')

                if len(data) > DATA_SIZE_DEFAULT:
                    raise SMTPDataError(552, 'Too much analytics data')

                if self.transport is None:
                    raise SMTPConnectError

            await self._handle_aesreport(data)
            await self.push('220 Ok')
        except SMTPException as e:
            if len(e.args) == 2:
                await self.push('{} {}'.format(e.args[0], e.args[1]))
            self.close()
            raise

    async def _handle_aesreport(self, data):
        try:
            decoded_report = b64decode(data)
        except BinASCIIError as e:
            raise SMTPDataError(500, 'Base64 decoding error: ' + str(e))
        try:
            report = loads(decoded_report.decode())
        except (TypeError, JSONDecodeError) as e:
            raise SMTPDataError(500, 'JSON decoding error: ' + str(e))
        self.envelope.report = report


class AdminQuarantineService(BaseFakeSMTPServer):
    protocol_class = ExSMTP
    delivery_class = AdminQuarantineDelivery

    def __init__(self, name, controller, settings, loop):
        super(AdminQuarantineService, self).__init__(
            name, controller, settings, loop)
        controller.settings['DELIVERY'][self.delivery_class.delivery_name] = {
            'class': 'aes.delivery.' + self.delivery_class.__name__,
            'command_encoding': 'utf-8',
        }

    @property
    def action(self):
        return {'name': 'admin_quarantine', 'smtp_endpoint': self.endpoint}


class UserQuarantineService(AdminQuarantineService):
    delivery_class = UserQuarantineDelivery

    @property
    def action(self):
        return {'name': 'user_quarantine', 'smtp_endpoint': self.endpoint}


class QuarantineController(BaseController):
    def __init__(self, name, owner, config, loop):
        self.settings = owner.settings
        config = config or {
            'user': {'class': UserQuarantineService},
            'admin': {'class': AdminQuarantineService},
        }
        super(QuarantineController, self).__init__(name, owner, config, loop)

    def optional(self, policy: PolicyTestService):
        if policy:
            policy.account_policy.data['quarantine'] = {
                'admin_quarantine': {
                    'smtp_endpoint': self['admin'].endpoint
                },
                'user_quarantine': {
                    'smtp_endpoint': self['user'].endpoint
                }
            }


class SendDeliveryWithReport(BaseFakeSMTPServer):
    protocol_class = ExSMTP

    def __init__(self, name, controller, settings, loop):
        super(SendDeliveryWithReport, self).__init__(
            name, controller, settings, loop)
        controller.settings['DELIVERY']['send'] = {
            'class': 'aes.delivery.StaticRouteDelivery',
            'host': self.host,
            'port': self.port,
            'command_encoding': 'utf-8',
        }
