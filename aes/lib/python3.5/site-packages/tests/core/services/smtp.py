import os
import ssl
from functools import partial

from aes.message import FixedMessage
from aes.core.smtp.protocol import SMTPProtocol
from aes.services.fake.base import BaseFakeService
from .base import get_certs_folder


class BaseFakeSMTPServer(BaseFakeService):
    protocol_class = SMTPProtocol
    data_size_limit = 2 ** 18
    handle_DATA = None
    enable_ssl = False
    enable_starttls = False
    require_tls = True

    def __init__(self, name, controller, config, loop):
        super(BaseFakeSMTPServer, self).__init__(
            name, controller, config, loop)
        self.server = None
        self.mail_box = []
        self.ssl_context = None
        self.tls_context = None
        if self.enable_ssl:
            self.ssl_context = ssl.create_default_context(
                ssl.Purpose.CLIENT_AUTH)
            path = get_certs_folder()
            self.ssl_context.load_cert_chain(
                os.path.join(path, 'server.crt'),
                os.path.join(path, 'server.key'),
            )
        if self.enable_starttls:
            self.tls_context = ssl.create_default_context(
                ssl.Purpose.CLIENT_AUTH)
            path = get_certs_folder()
            self.tls_context.load_cert_chain(
                os.path.join(path, 'server.crt'),
                os.path.join(path, 'server.key')
            )

    def get_factory(self):
        return partial(
            self.protocol_class,
            self,
            data_size_limit=self.data_size_limit,
            enable_SMTPUTF8=True,
            loop=self.loop,
            hostname=self.name,
            tls_context=self.tls_context,
            require_starttls=self.require_tls,
        )

    async def get_server(self):
        return await self.loop.create_server(
            self.get_factory(),
            ssl=self.ssl_context,
            sock=self.sock
        )

    async def start(self):
        self.server = await self.get_server()

    async def handle_data(self, envelope):
        envelope.content = envelope.original_content.decode(
            'ASCII', errors='surrogateescape')
        envelope.message = FixedMessage.from_string(envelope.content)
        envelope.ssl = envelope.session.ssl
        envelope.over_ssl = envelope.session.protocol._over_ssl
        self.mail_box.append(envelope)
        return '250 queued as %s' % len(self.mail_box)

    @property
    def endpoint(self):
        return 'smtp:%s:%s' % (self.host, self.port)


class SendSMTPTestServer(BaseFakeSMTPServer):
    def __init__(self, name, controller, settings, loop):
        super(SendSMTPTestServer, self).__init__(
            name, controller, settings, loop)
        controller.settings['DELIVERY']['send'] = {
            'class': 'aes.delivery.SendDelivery',
            'out_host': self.host,
            'out_port': self.port,
        }


class NamedDelivery(BaseFakeSMTPServer):
    delivery_name = None
    raw_data = False
    ssl_settings = None
    tls_settings = None

    def __init__(self, name, controller, config, loop):
        super(NamedDelivery, self).__init__(name, controller, config, loop)
        controller.settings['DELIVERY'][self.delivery_name] = {
            'class': 'aes.delivery.StaticRouteDelivery',
            'host': self.host,
            'port': self.port,
            'command_encoding': 'utf-8',
            'ssl': self.ssl_settings,
            'starttls': self.tls_settings,
            'raw_data': self.raw_data
        }


class SendDelivery(NamedDelivery):
    delivery_name = 'send'


class DenyDelivery(NamedDelivery):
    delivery_name = 'deny'


class NDRDelivery(NamedDelivery):
    delivery_name = 'ndr'
